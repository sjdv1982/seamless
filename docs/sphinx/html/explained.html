<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Seamless explained &mdash; Seamless 0.8 documentation</title><link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Recipe for a new Seamless project" href="new-project.html" />
    <link rel="prev" title="Beginner’s guide" href="beginner.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> Seamless
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">Introduction</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="whatis.html">Seamless: a cell-based interactive workflow framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting-started.html">Getting started with Seamless</a></li>
<li class="toctree-l1"><a class="reference internal" href="beginner.html">Beginner’s guide</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Seamless explained</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#core-concepts">Core concepts</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#checksums">Checksums</a></li>
<li class="toctree-l3"><a class="reference internal" href="#interactivity">Interactivity</a></li>
<li class="toctree-l3"><a class="reference internal" href="#using-seamless-as-a-reactive-web-framework">Using Seamless as a reactive web framework</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cells">Cells</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#demonstration">Demonstration</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#dependent-and-independent-data">Dependent and independent data</a></li>
<li class="toctree-l3"><a class="reference internal" href="#caching">Caching</a></li>
<li class="toctree-l3"><a class="reference internal" href="#transformations">Transformations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#transformers-vs-transformations">Transformers vs. transformations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#types-of-transformations">Types of transformations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#deployment-of-transformations">Deployment of transformations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#deep-structures">Deep structures</a></li>
<li class="toctree-l3"><a class="reference internal" href="#visualization-and-monitoring">Visualization and monitoring</a></li>
<li class="toctree-l3"><a class="reference internal" href="#understanding-seamless-dependency-graphs">Understanding Seamless dependency graphs</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#guidelines-for-experienced-developers">Guidelines for experienced developers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#keep-it-simple-while-you-can">Keep it simple, while you can</a></li>
<li class="toctree-l3"><a class="reference internal" href="#programming-in-two-places">Programming in two places</a></li>
<li class="toctree-l3"><a class="reference internal" href="#moving-away-from-jupyter">Moving away from Jupyter</a></li>
<li class="toctree-l3"><a class="reference internal" href="#edit-the-editor">Edit the editor</a></li>
<li class="toctree-l3"><a class="reference internal" href="#environments">Environments</a></li>
<li class="toctree-l3"><a class="reference internal" href="#don-t-confuse-files-and-cell-names">Don’t confuse files and cell names</a></li>
<li class="toctree-l3"><a class="reference internal" href="#don-t-rely-on-file-names-or-urls">Don’t rely on file names or URLs</a></li>
<li class="toctree-l3"><a class="reference internal" href="#use-celltypes">Use celltypes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#use-schemas">Use schemas</a></li>
<li class="toctree-l3"><a class="reference internal" href="#use-structured-cells">Use structured cells</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="new-project.html">Recipe for a new Seamless project</a></li>
</ul>
<p class="caption"><span class="caption-text">Seamless features</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="context.html">Contexts</a></li>
<li class="toctree-l1"><a class="reference internal" href="cell.html">Cells</a></li>
<li class="toctree-l1"><a class="reference internal" href="transformer.html">Transformers</a></li>
<li class="toctree-l1"><a class="reference internal" href="mounting.html">Mounting to the file system</a></li>
<li class="toctree-l1"><a class="reference internal" href="shareserver.html">The Seamless shareserver</a></li>
<li class="toctree-l1"><a class="reference internal" href="help.html">The help system</a></li>
<li class="toctree-l1"><a class="reference internal" href="visualization.html">Visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="validation.html">Validation</a></li>
<li class="toctree-l1"><a class="reference internal" href="libraries.html">Libraries and libinstances</a></li>
<li class="toctree-l1"><a class="reference internal" href="modules.html">Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="job_management.html">Job management</a></li>
<li class="toctree-l1"><a class="reference internal" href="deployment.html">Deployment</a></li>
</ul>
<p class="caption"><span class="caption-text">Advanced features</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="deepcell.html">Deep cells</a></li>
<li class="toctree-l1"><a class="reference internal" href="low_level.html">Macros and the low level</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="reference.html">Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Seamless</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Seamless explained</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/explained.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="seamless-explained">
<h1>Seamless explained<a class="headerlink" href="#seamless-explained" title="Permalink to this headline">¶</a></h1>
<div class="section" id="core-concepts">
<h2>Core concepts<a class="headerlink" href="#core-concepts" title="Permalink to this headline">¶</a></h2>
<p>First, Seamless is a framework for <em>interactive</em> programming and scripting. There are essentially two ways that you can do this. The first is file-based, like the bash shell. The second is cell-based, such as IPython, Jupyter, or a spreadsheet. Seamless follows the cell-based approach.</p>
<p>Second, Seamless is a framework for building <em>workflows</em> (dataflow programming), i.e. dependency graphs. There are essentially three ways you can do this: stream-based (NoFlo), file-based (NextFlow, Snakemake) or cell-based (Jupyter, Excel). Again, Seamless follows the cell-based approach.</p>
<p>In a nutshell, most of Seamless revolves around <em><strong>cells</strong></em>, that hold the data and code, and <em><strong>transformers</strong></em>, that do the computation. Transformers take cells (including code cells) as input and have a single cell as output.</p>
<div class="section" id="checksums">
<h3>Checksums<a class="headerlink" href="#checksums" title="Permalink to this headline">¶</a></h3>
<p>What makes Seamless special is that cells don’t hold values or filenames, but <em><strong>checksums</strong></em> (aka hashes, aka content-addressed storage). This has several implications. First, unlike e.g. NextFlow, you aren’t tied to a hierarchy of files, carefully named and accessible on a mounted file system. In contrast, while in Seamless you <em>can</em> mount a cell to a file, it just means that the cell’s checksum tracks the file content when it changes (and vice versa). Computations can be executed anywhere, without copying over any files first. Second, it means that copying a cell is always free in terms of space, in the same way that a hardlink to a file is always free (but copying a file or value is not). Third, although they give the illusion of wrapping an in-memory value, Seamless cells do no such thing. They just contain checksums, and data values are obtained only when they are needed. Checksums are small, and a workflow description with checksums is small, but their underlying data can be much larger than what fits in memory, or on disk. In other words, big data is possible with Seamless.</p>
<p>On the flip side, you can’t automatically assume that you have a cell’s data at your fingertips. By default, Seamless sets up some simple checksum-to-data stores, but that reintroduces some of the problems (potential memory issues, file copying) of using files and values instead of checksums. These problems can be minimized by manually configuring your data storage.</p>
<p>The final implication is that since transformers are also based on checksums, and since these checksums fully describe the computation (parameters <em>and</em> code <em>and</em> result), you can replace a computation with its result, and replace a result with its computation (referential transparency). This is very beneficial for <em><strong>reproducibility</strong></em>, and it provides <em><strong>reactivity</strong></em>: after cell updates, it is always obvious which computations need to be re-executed. No need for manual re-execution (Jupyter) or reliance on file modification times (Snakemake). Finally, it means that computations are small to describe, and can run anywhere, as long as they can locate the data of their input checksums. More details are in the transformation section.</p>
</div>
<div class="section" id="interactivity">
<h3>Interactivity<a class="headerlink" href="#interactivity" title="Permalink to this headline">¶</a></h3>
<p>Seamless has three features that contribute to interactivity.</p>
<p>First, based on the reactivity explained above. You can essentially re-run the entire workflow continuously without much cost, because recomputation only happens if something changes.</p>
<p>Second, while the workflow remains running, you can always modify it in IPython/Jupyter. Both the topology of the workflow and the parameters can be modified.</p>
<p>Third, Seamless allows cells to be <em><strong>synchronized</strong></em>. There are two mechanisms for this. The first mechanism is that during development, cells can be synchronized (mounted) to the file system. In this way, you can define a code cell initially in a Jupyter Notebook, but then link it to a source code file under Git version control that you can edit with a standard text editor or IDE. The synchronization is two-way, which means that the file contains the cell buffer, and that the cell contains the file checksum. During deployment, the file is no longer needed (or used), although the cell buffer must be retrievable from somewhere.</p>
<p>The other mechanism of synchronization is over HTTP. You can expose cells as read-only, allowing their value to be read in the browser (HTTP GET), or as read-write, so that they can be modified (HTTP PUT). There is also a websocket port where you can receive notifications from Seamless when a cell has been updated. Seamless includes a simple javascript client that uses all of this to synchronize cell values bidirectionally between Seamless and the browser. This is how you build web interfaces that are fundamentally interactive.</p>
<p>In Seamless, there is no sharp difference between user and programmer. All sources of interactivity are treated the same: change of a cell over HTTP, change of a cell linked to the file system, or modification of the entire workflow via IPython. From Seamless’s point of view, they are all acts of programming, although the user of a web interface normally has a very limited “API” at their disposition. You <em>can</em> allow actual programming via the web interface, by exposing code cells in read-write mode and link them to textarea editor elements in your HTML page. If you really want to.</p>
</div>
<div class="section" id="using-seamless-as-a-reactive-web-framework">
<h3>Using Seamless as a reactive web framework<a class="headerlink" href="#using-seamless-as-a-reactive-web-framework" title="Permalink to this headline">¶</a></h3>
<p>Seamless’s automatic reactivity and interactivity makes it very convenient to make a certain type of web services. No matter what, you don’t have to write server code that explicitly handles dynamic change, while this is required if you use Django or React or Flask or any of those web frameworks. <em><strong>Seamless workflows don’t handle dynamic change, because there is none</strong></em>. Whenever something changes, Seamless effectively discards the old workflow and replaces it with a new workflow. All computations that were excuted before by the old workflow (or that were ever executed by any workflow at all!) can be re-used. In that sense, Seamless is more similar to a traditional static CGI web server, which doesn’t require any dynamic change either.</p>
<p>However, the big difference with a static web server is that a dynamic, reactive web server must always be live: there must always a Seamless process that listens for HTTP updates. You can’t simply wait until the user submits a static webform with all the parameters and then fire up your workflow. Likewise, the browser must be live too, and listen from continuous updates from the server, but this is easy to do nowadays (web sockets).</p>
</div>
<div class="section" id="cells">
<h3>Cells<a class="headerlink" href="#cells" title="Permalink to this headline">¶</a></h3>
<p>A cell is essentially a container that holds a <em>checksum</em> (a SHA3-256 hash). A checksum corresponds to a <em>buffer</em> (the raw bytes). This correspondence is one-to-one: each buffer has a unique checksum and vice versa. Finally, the <em>celltype</em> describes how the buffer is to be interpreted (<em>deserialized</em>) into a <em>value</em>. For example, celltype “plain” means a conversion to a Python string (which means UTF-8 decoding) followed by loading the string as JSON. Likewise, to go from value to buffer (<em>serialization</em>), a value of celltype “plain” is first converted to a JSON string, and then encoded (using UTF-8) into a byte buffer.</p>
<p>Concretely, the byte buffer <code class="docutils literal notranslate"><span class="pre">42\n</span></code> corresponds to the value <code class="docutils literal notranslate"><span class="pre">42</span></code> for celltype “plain”, and vice versa.</p>
<p>There is also a celltype “python”, which means that a cell can contain not only data, but also code.</p>
<p>Using the Seamless API in Python gives the <em>illusion</em> that Seamless cells are containers of <em>values</em>, just like:</p>
<ul class="simple">
<li><p>variables in Python</p></li>
<li><p>code cells in Jupyter</p></li>
<li><p>value cells and formula cells in Microsoft Excel.</p></li>
</ul>
<p>However, internally, whenever you <em>set</em> the value of a cell:</p>
<ul class="simple">
<li><p>Seamless serializes the value to a buffer, using the celltype.</p></li>
<li><p>Seamless calculates the checksum of the buffer.</p></li>
<li><p>Seamless stores the checksum in the cell. The cell does not store the value or buffer.</p></li>
</ul>
<p>Likewise, when you <em>ask</em> for the value of the cell:</p>
<ul class="simple">
<li><p>Seamless reads the cell’s checksum.</p></li>
<li><p>Seamless retrieves the buffer corresponding to the checksum.</p></li>
<li><p>Seamless deserializes the buffer into a value, using the celltype.</p></li>
</ul>
<div class="section" id="demonstration">
<h4>Demonstration<a class="headerlink" href="#demonstration" title="Permalink to this headline">¶</a></h4>
<p>Define a cell with a value “testvalue”</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">seamless.highlevel</span> <span class="kn">import</span> <span class="n">Context</span><span class="p">,</span> <span class="n">Cell</span>
<span class="n">ctx</span> <span class="o">=</span> <span class="n">Context</span><span class="p">()</span>
<span class="n">ctx</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">Cell</span><span class="p">(</span><span class="s2">&quot;plain&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;testvalue&quot;</span><span class="p">)</span>
<span class="n">ctx</span><span class="o">.</span><span class="n">translate</span><span class="p">()</span>
</pre></div>
</div>
<p>The checksum, buffer and value can then be obtained as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">checksum</span><span class="p">)</span>
<span class="go">93237a60bf6417104795ed085c074d52f7ae99b5ec773004311ce665eddb4880</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">buffer</span><span class="p">)</span>
<span class="go">b&#39;&quot;testvalue&quot;\n&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">testvalue</span>
</pre></div>
</div>
<p>With <code class="docutils literal notranslate"><span class="pre">ctx.resolve</span></code>, buffers and values can be obtained in a generic way:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span>
<span class="go">    &quot;93237a60bf6417104795ed085c074d52f7ae99b5ec773004311ce665eddb4880&quot;</span>
<span class="go">))</span>
<span class="go">b&#39;&quot;testvalue&quot;\n&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span>
<span class="go">    &quot;93237a60bf6417104795ed085c074d52f7ae99b5ec773004311ce665eddb4880&quot;,</span>
<span class="go">    &quot;plain&quot;</span>
<span class="go">))</span>
<span class="go">testvalue</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="dependent-and-independent-data">
<h3>Dependent and independent data<a class="headerlink" href="#dependent-and-independent-data" title="Permalink to this headline">¶</a></h3>
<p><em><strong>IMPORTANT: This documentation section is an early draft. The raw text material is shown below</strong></em></p>
<p>TODO: merge with the corresponding paragraph in context.md
…
By default, Seamless maintains a checksum-to-data cache in-memory that distinguish between <em>dependent</em> (computed) and <em>independent</em> data. Dependent data may get evicted … TODO</p>
<ul class="simple">
<li><p>Independent vs dependent: history doesn’t matter, creating a new workflow… syntax…
Deeper:</p></li>
<li><p>Fingertipping, cache misses and irreproducibility (link to transformer)</p></li>
<li><p>Resolving cycles…</p></li>
<li><p>bidirectional link</p></li>
<li><p>Async tasks (link to low_level.md)</p></li>
</ul>
</div>
<div class="section" id="caching">
<h3>Caching<a class="headerlink" href="#caching" title="Permalink to this headline">¶</a></h3>
<p><em><strong>IMPORTANT: This documentation section is a draft. The preliminary text is shown below</strong></em></p>
<p>TODO</p>
<ul class="simple">
<li><p>Various kinds of caches in Seamless</p></li>
</ul>
<p>The checksum-to-buffer conversion cache is more than just for performance. The
correspondence between checksum and buffer is one-to-one, but you can only compute
the checksum from a buffer, not the other way around. Therefore,
it is essential that for each checksum, the corresponding buffer is available
where needed.</p>
<p>In addition, sometimes very large buffers must be converted between different cell
types, e.g. from text to JSON. Caching the conversion will avoid the loading of
the source buffer from wherever it is stored. Seamless also caches the length of
buffers and other info statistics, to reason if a conversion is a priori impossible
or trivial.</p>
<p>Finally, Seamless has a last-resort function to go from checksum to buffer. It is possible to define a list of buffer servers ($SEAMLESS_BUFFER_SERVERS) and Seamless will try to contact them. By default, it contains the RPBS buffer server, so that <code class="docutils literal notranslate"><span class="pre">https://buffer.rpbs.univ-paris-diderot.fr/&lt;checksum&gt;</span></code> will be contacted.</p>
</div>
<div class="section" id="transformations">
<h3>Transformations<a class="headerlink" href="#transformations" title="Permalink to this headline">¶</a></h3>
<p>Large scale computing means the deployment of computations to remote systems.</p>
<p>In principle, there are five ways to do that:</p>
<ul class="simple">
<li><p>Remote Procedure Call (RPC). There are many frameworks that can do this, for example ipycluster and execnet. In essence, everything is packaged into a single command message that is sent to the remote service. All of the input values and code are serialized (pickled) and the remote service is asked to execute the command. This is reproducible, since the result is completely defined by the command message. But the command message can be extremely big, since it embeds all input values.</p></li>
<li><p>Remote execution using file names. This is what Slurm does for single computations, and NextFlow/Snakemake for workflows. The command messages are small, but they rely on a shared file system. Organizing files into inputs, outputs, versioned banks etc. requires mental effort and discipline. Reproducibility is an issue: there is no guarantee that a file name always refers to the same value. File modification time is used to detect this, but this only works within the same file system. Federation is therefore not easily possible: sharing files is difficult (files can be big) and fragile in terms of reproducibility (need to preserve modification times). If command line tools are sloppy (creating hidden output files that are implicitly needed by downstream tools, or having implicit file dependencies), some very strange errors can happen. See “Don’t rely on file names” for an example where this can go wrong.</p></li>
<li><p>Remote execution using URLs. This is essentially the same as file names, but using the Internet as a global file system. Federation is much easier, but reproducibility (already hard) is now much harder (no control over remote sites,  cannot use modification times). Requires immense discipline in using globally unique identifiers for URLs (discipline that the PDB and UniProt do not have).</p></li>
<li><p>Remote execution inside an environment (conda, Docker container). This works well if the environment is popular and stable, i.e. you can re-use the same environment over and over again. If the environment itself is under active development, this method is a disaster.</p></li>
<li><p>The fifth method is how Seamless does it. Remote execution is done by providing the checksums of the inputs and of the code. This is what Seamless call a <em>transformation</em>. The remote service is then responsible to retrieve the corresponding buffers/values. This means that a computation is always well-defined, but not always executable: it may fail if one or more buffers cannot be found. In contrast, in the first three methods, a computation becomes only well-defined when it becomes executable.</p></li>
</ul>
<div class="section" id="transformers-vs-transformations">
<h4>Transformers vs. transformations<a class="headerlink" href="#transformers-vs-transformations" title="Permalink to this headline">¶</a></h4>
<p>A transformer is essentially a container that holds a transformation. A transformer has cells as input, whereas a transformation has the checksums of those cells as input.</p>
<p>A transformation describes a unique computation that transforms the input checksums (including the code checksum) into a result checksum. Each input checksum has a name and a celltype. When the transformation is executed, each input checksum is converted to a variable with the same name, and whose value is obtained in the same way as for cells.</p>
</div>
<div class="section" id="types-of-transformations">
<h4>Types of transformations<a class="headerlink" href="#types-of-transformations" title="Permalink to this headline">¶</a></h4>
<p>Seamless allows a transformation to contain an <em>environment</em>: as a Docker image, a conda environment definition, or a list of command line tools that must be available. This is a bit informal and should be used with care when it comes to reproducibility. See the <a class="reference external" href="http://sjdv1982.github.io/seamless/sphinx/html/environments.html">documentation of environments</a> for more details.</p>
<p>In addition, Seamless transformers can in principle be written in any language. Python/IPython transformers are executed directly. Interpreted languages (e.g. R) are executed via a bridge to IPython (e.g. using rpy). Bash transformers are executed using a special Python function. So are compiled transformers (e.g. in C++) after compilation.</p>
<p>The following combinations of language and environment are currently possible for Seamless transformations:</p>
<ul class="simple">
<li><p>Transformers written in bash, with no environment (pure UNIX commands)</p></li>
<li><p>Transformers written in bash, with a Docker image environment.</p></li>
<li><p>Generic transformers (Python, compiled, etc.), with no environment</p></li>
<li><p>Generic transformers, with a conda environment.</p></li>
</ul>
</div>
<div class="section" id="deployment-of-transformations">
<h4>Deployment of transformations<a class="headerlink" href="#deployment-of-transformations" title="Permalink to this headline">¶</a></h4>
<p>Each Seamless instance is able to do its own computation, but during deployment, this is normally not very efficient. So Seamless has a protocol (communion protocol) where a Seamless instance can delegate transformation requests (jobs) to another Seamless instance (a jobslave)or to a dedicated job manager (jobless). Transformation requests can then be delegated further, e.g. to a job slave on a HPC cluster.</p>
<p>Then, from a computing viewpoint, a Seamless instance can be seen as a black box, where cell values come in (via HTTP) and a stream of transformation requests come out. The transformation requests are small, as they contain only checksums.</p>
<p>The communion protocol can also exchange buffers, but it is easier if both the Seamless instance and the job slave have access to the same Seamless database (see <a class="reference external" href="http://sjdv1982.github.io/seamless/sphinx/html/data_storage.html">documentation</a>).
In that case, the buffers corresponding to the input checksums will have beenpre-deposited by the Seamless instance, so only the transformation needs to be sent. After computation, the jobslave will deposit the result checksum for that transformation, and the corresponding buffer. The Seamless instance needs to interrogate only the database to retrieve the results.</p>
</div>
</div>
<div class="section" id="deep-structures">
<h3>Deep structures<a class="headerlink" href="#deep-structures" title="Permalink to this headline">¶</a></h3>
<p><em><strong>IMPORTANT: This documentation section is an early draft. The raw text material is shown below</strong></em></p>
<p>TODO: move/clone into deepcell.md</p>
<p>A transformation is in fact a “deep structure”. Its checksum corresponds to a dictionary, where each value is itself a checksum (of the input cells).</p>
<p>Seamless has support for two other kinds of deep structures: deep cells and deep folders. In both cases, the deep structure is again a dictionary, where the keys are strings and the values are checksums. The difference is the cell type of the checksums. For deep cells, the cell type is “mixed” (Seamless’s default cell type), which means that you can easily access an individual element and convert it trivially to a normal Seamless cell. In contrast, for deep folders, the cell type is “bytes”, which means that buffer and value are the same. This allows a one-to-one mapping with a
folder on the file system.</p>
</div>
<div class="section" id="visualization-and-monitoring">
<h3>Visualization and monitoring<a class="headerlink" href="#visualization-and-monitoring" title="Permalink to this headline">¶</a></h3>
<p><em><strong>IMPORTANT: This documentation section is an early draft. The raw text material is shown below</strong></em></p>
<p>TODO: integrate/merge with visualization.md</p>
<p>Typically, a web service consists of two graphs (.seamless files).
The first graph contains the main workflow. The second graph contains a status graph. The status graph can be bound by Seamless to the main graph (<code class="docutils literal notranslate"><span class="pre">seamless.metalevel.bind_status_graph</span></code>; this function is automatically invoked by <code class="docutils literal notranslate"><span class="pre">seamless-serve-graph</span></code> if you provide two graph files). In that case, the status graph receives the current value and status of the  main workflow graph as its input, and normally visualizes it as a web page. Manually-coded web interfaces are normally added to the main workflow graph. In contrast, the automatic web interface generator is part of the status graph, as it generates the web interface HTML by taking the main workflow graph as an input. During development, both graphs are developed, which is made possible by <code class="docutils literal notranslate"><span class="pre">seamless-new-project</span></code> and <code class="docutils literal notranslate"><span class="pre">seamless-load-project</span></code>.</p>
</div>
<div class="section" id="understanding-seamless-dependency-graphs">
<h3>Understanding Seamless dependency graphs<a class="headerlink" href="#understanding-seamless-dependency-graphs" title="Permalink to this headline">¶</a></h3>
<p><em><strong>IMPORTANT: This documentation section is an outline. The outline is shown below</strong></em></p>
<ul class="simple">
<li><p>Topology vs parameters.</p></li>
<li><p>Seamless translation machinery (midlevel), metalevel. How the high level wraps the graph data structure</p></li>
<li><p>Discussion of the limitations of workflows (dependency graphs): if statements, for loops.
Dummy solution: for loop and if statement inside transformer code.
Proper duration of a transformer: seconds to minutes.
Alternative solution: move away from dependency graph, launch jobs imperatively (Prefect 2.0).</p></li>
<li><p>Ways to work around these limitations:
libraries and macros.
Note that library instances require translation, macros do not. Translation is in fact a macro.</p></li>
<li><p>Always keep a test where you maintain interactivity.</p></li>
</ul>
<p>Practical:</p>
<ul class="simple">
<li><p>Scatter transformers</p></li>
<li><p>stdlib.map</p></li>
<li><p>Elision and incremental computing</p></li>
<li><p>Hacking the midlevel</p></li>
</ul>
</div>
</div>
<div class="section" id="guidelines-for-experienced-developers">
<h2>Guidelines for experienced developers<a class="headerlink" href="#guidelines-for-experienced-developers" title="Permalink to this headline">¶</a></h2>
<div class="section" id="keep-it-simple-while-you-can">
<h3>Keep it simple, while you can<a class="headerlink" href="#keep-it-simple-while-you-can" title="Permalink to this headline">¶</a></h3>
<p>The beginner’s guide’s section on “how to keep it simple” contains good advice for a small, young project. With Jupyter, you can quickly set something up, adding Seamless’s interactivity to Jupyter’s own. This works best for workflows that are non-linear but with not too many steps, where the data is rather small, and the code too.</p>
<p>When the code gets more complex, you should move away from Jupyter by mounting your code cells to files. Code that modifies the workflow becomes throw-away code. See “Moving away from Jupyter” for more details.</p>
<p>When the data gets bigger, or execution becomes time-consuming, you should start thinking about <a class="reference external" href="http://sjdv1982.github.io/seamless/sphinx/html/data_storage.html">data storage</a> and <a class="reference external" href="http://sjdv1982.github.io/seamless/sphinx/html/job_management.html">job management</a>. With default settings, Seamless transformations are parallelized on your local machine and cached in memory, and you may want to change that. If the data gets really big, you should bring the computation where the data is. But even in that case, try to have a small-data version of your workflow that executes fast, so that you can modify the code easily and interactively. Whitelists work very well for this <a class="reference external" href="http://sjdv1982.github.io/seamless/sphinx/html/deep_cells.html">see deep cells</a>.</p>
<p>If either the code or the data gets bigger, you should start thinking about version control, and whether or not to use <code class="docutils literal notranslate"><span class="pre">seamless-new-project</span></code>. See <a class="reference external" href="http://sjdv1982.github.io/seamless/sphinx/html/new-project.html">the documentation for creating a Seamless project</a> for more details.</p>
</div>
<div class="section" id="programming-in-two-places">
<h3>Programming in two places<a class="headerlink" href="#programming-in-two-places" title="Permalink to this headline">¶</a></h3>
<p>Clearly distinguish between the “outside” code that <em>creates</em> the workflow, and the “inside” code (mostly within transformers) that is executed as part of the workflow. Inside codes are polyglot and executed in isolation (from each other, and from the outside). Outside code is written in Python, and you run it inside IPython or Jupyter. You don’t need to keep outside code, because you can store the entire workflow as data. The “Programming in two places” section in the beginner’s guide explains it in slightly more detail.</p>
<p>The “Moving away from Jupyter” section below explains that you should mount your code cells to the file system, and then remove their code from the notebook. Once it has thus become part of your workflow, Seamless will store the code (at least its checksum, and normally its content too), and you can also store it under Git version control as a file. Note that this applies only to “inside” code. In contrast, in a mature project, “outside” code that inspects or modifies the workflow should be considered <em><strong>throw-away code</strong></em>. If you have moved away completely from Jupyter, you can simply use <code class="docutils literal notranslate"><span class="pre">seamless-ipython</span></code> to enter such code. Else, you can enter it in a temporary notebook cell, or use <code class="docutils literal notranslate"><span class="pre">seamless-jupyter-connect</span></code> to connect an IPython-like console to Jupyter. In all cases, you execute the code, but you don’t keep it: instead, you simply save the state of the workflow in a <code class="docutils literal notranslate"><span class="pre">.seamless</span></code> file.</p>
<p>There is one use case where “outside” code may be kept. When it comes to describing the topology of the workflow (the steps and connections), you should normally rely on the status visualization web page (which you can modify, see “Edit the editor”) or create your own flowcharts. But if that is not to your satisfaction, you do have the option to define your workflow topology from code. In that case, modify the Seamless project’s <code class="docutils literal notranslate"><span class="pre">define_graph</span></code> function in <code class="docutils literal notranslate"><span class="pre">load-project.py</span></code>. If you do so, <code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">load()</span></code> will execute that code instead of loading the <code class="docutils literal notranslate"><span class="pre">.seamless</span></code> file, assuming that it will build the connections and cell mounts of the workflow. If you don’t use a Seamless project at all, simply store the “outside” code in a script and run it.</p>
</div>
<div class="section" id="moving-away-from-jupyter">
<h3>Moving away from Jupyter<a class="headerlink" href="#moving-away-from-jupyter" title="Permalink to this headline">¶</a></h3>
<p>Seamless gives the illusion of being like Jupyter, but with non-linear execution. The <strong>web server demo</strong>( <a class="reference external" href="https://github.com/sjdv1982/seamless/tree/stable/examples/webserver-demo">open on GitHub</a>, or <a class="reference external" href="https://mybinder.org/v2/gh/sjdv1982/seamless-binder-demo/main?labpath=webserver.ipynb">run on mybinder.org</a>) gives an example where you start from a simple notebook and port it to Seamless, gaining an interactive web interface in the process. It is also about as far as you can push a Seamless workflow that is defined purely in Jupyter. Why is this? At the end of the demo, the next step would be to mount each code cell to a Python file, so that you can start modifying the calculation code of the workflow using a normal text editor or IDE. Whenever you save the file, the cell value is updated and the workflow recalculated. Each Python file can be put under Git version control, something that <code class="docutils literal notranslate"><span class="pre">seamless-new-project</span></code> sets up by default. However, the original unmodified code is still in the notebook! So if you re-run the notebook, and you re-mount the Python files, Seamless has to choose which version is correct: the one in the Python file, or the one in the notebook. In other words, either all of your modifications in the Python file get lost, or the code in the Python file supersedes the code of the notebook. By default, Seamless does the second thing (and gives you a warning), but it’s ugly to have your notebook telling lies. It goes against the spirit of a notebook that tells a linear story on how you started from scratch and arrived at a result. And if then further modify the code also in the notebook, there will be no end of trouble. So in that case, the correct thing to do is to give up on the linear story and remove the now-outdated code from the notebook.</p>
<p>Another case is the web interface generator, which is all based on files (<code class="docutils literal notranslate"><span class="pre">webform.json</span></code>, <code class="docutils literal notranslate"><span class="pre">index.html</span></code>, <code class="docutils literal notranslate"><span class="pre">index.js</span></code>) that are being auto-generated but that can be modified. In fact, these files are Seamless cells of a secondary context <code class="docutils literal notranslate"><span class="pre">webctx</span></code> that are mounted to the file system (also see “Edit the editor”). Re-loading the notebook, executing cells that re-build the workflow bit-by-bit, is bound to give merge conflicts with a file that contains the modified web interface for the entire workflow in its final state.</p>
<p>In summary, <em><strong>once you start offloading your workflow to edited files, the time for linear notebook storytelling is over</strong></em>. Does that mean that you should abandon Jupyter altogether? Not necessarily. You can keep Jupyter around as a dashboard, linking Seamless <code class="docutils literal notranslate"><span class="pre">Cell.traitlet</span></code> and <code class="docutils literal notranslate"><span class="pre">Cell.output</span></code> with ipywidgets. Or you can still use it as a scratch pad where you can quickly try out code, then incorporate it into your workflow when it seems to work, deleting it from the notebook.</p>
<p>Note that all of this applies primarily to “inside” code. In contrast, “outside” code is normally throw-away code. See “Programming in two places” for detail.</p>
</div>
<div class="section" id="edit-the-editor">
<h3>Edit the editor<a class="headerlink" href="#edit-the-editor" title="Permalink to this headline">¶</a></h3>
<p><em><strong>IMPORTANT: This documentation section is an early draft. The raw text material is shown below</strong></em></p>
<p>TODO: perhaps merge with “visualization and monitoring”.
(Status graph is your friend)
Don’t be afraid to modify it (Link to last paragraph in visualization). If you have HTML/JS skills, you can organize the cells and transformers into cleaner flowcharts. Beyond that, there is nothing to stop you from extending the webctx further into a full visual programming interface.
Light-weight experience: don’t use seamless-new-project at all</p>
</div>
<div class="section" id="environments">
<h3>Environments<a class="headerlink" href="#environments" title="Permalink to this headline">¶</a></h3>
<p>The beginner’s guide’s documentation recommends to install packages in the running Docker container. Don’t do that. Study the <a class="reference external" href="http://sjdv1982.github.io/seamless/sphinx/html/environments.html">documentation of environments</a> instead.</p>
</div>
<div class="section" id="don-t-confuse-files-and-cell-names">
<h3>Don’t confuse files and cell names<a class="headerlink" href="#don-t-confuse-files-and-cell-names" title="Permalink to this headline">¶</a></h3>
<p>See the beginner’s guide on “Don’t confuse files and cell names”. In addition, note that file mounting is something that happens only during development. When you save a workflow, the file’s checksum gets incorporated into it. When you deploy a workflow (e.g. with <code class="docutils literal notranslate"><span class="pre">seamless-serve-graph</span></code>, Cloudless, or loading a .seamless file yourself), mounts are not needed to make the workflow run.</p>
</div>
<div class="section" id="don-t-rely-on-file-names-or-urls">
<h3>Don’t rely on file names or URLs<a class="headerlink" href="#don-t-rely-on-file-names-or-urls" title="Permalink to this headline">¶</a></h3>
<p>If you need external files or directories, add their <em>checksums</em> explicitly to the workflow (inside a normal cell for files, and inside a FolderCell or DeepFolderCell for directories). Else, reproducibility will be broken. The same applies for other external data sources, such as URLs or databases. In other words, reading an external data source must be <em>outside</em> code (see “Programming in two places”), it must be done inside IPython or Jupyter, and <em>not</em> inside transformer code. See the beginner’s guide on “Don’t rely on file names or URLs” for more details.</p>
<p>There is one exception to this rule: you may choose to embed external data sources in the environment, by installing them inside a Docker image. In that case, reproducibility is guaranteed by the checksum of the Docker image, and you are highly recommended to include it in the Docker image name in <code class="docutils literal notranslate"><span class="pre">Transformer.docker_image</span></code> (e.g “jupyter/scipy-notebook&#64;sha256:a891adee079e8c3eee54fef732cd282fe6b06c5fabe1948b9b11e07144526865” for a specific version of Jupyter). In that case, it is fine to refer to the file name of the data source inside transformer code. Of course, when your external data source changes, you must rebuild the Docker image and change <code class="docutils literal notranslate"><span class="pre">Transformer.docker_image</span></code> to reflect the new Docker image checksum.</p>
</div>
<div class="section" id="use-celltypes">
<h3>Use celltypes<a class="headerlink" href="#use-celltypes" title="Permalink to this headline">¶</a></h3>
<p>By default, every cell is a structured cell, which is normally overkill. Structured cells are great for subcell access and for schemas, but not every cell needs those features. Setting the celltype to something simpler may clarify the workflow.</p>
<p>All celltypes and their conversions are described in the <a class="reference external" href="http://sjdv1982.github.io/seamless/sphinx/html/cell.html">cell documentation</a>. Note that transformer pins have celltypes too. Their default celltype is “mixed”.</p>
</div>
<div class="section" id="use-schemas">
<h3>Use schemas<a class="headerlink" href="#use-schemas" title="Permalink to this headline">¶</a></h3>
<p><em><strong>IMPORTANT: This documentation section is an early draft. The raw text material is shown below</strong></em></p>
<p>Transformer code is not the correct place for validation. Use schemas instead.</p>
</div>
<div class="section" id="use-structured-cells">
<h3>Use structured cells<a class="headerlink" href="#use-structured-cells" title="Permalink to this headline">¶</a></h3>
<p><em><strong>IMPORTANT: This documentation section is an early draft. The raw text material is shown below</strong></em></p>
<p>Because of subcell access and schemas, and integration of independent (auth) and dependent (inchannel) data, and cyclic dependencies, and object oriented programming. Same reason why beginners should avoid them. Keep them small, else use DeepCells. At odds with “use celltypes”.</p>
</div>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="beginner.html" class="btn btn-neutral float-left" title="Beginner’s guide" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="new-project.html" class="btn btn-neutral float-right" title="Recipe for a new Seamless project" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016-2022, INSERM, CNRS and code contributors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>