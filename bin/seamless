#!/usr/bin/env python3

__version__ = "0.12"

import argparse
import sys
import os
from pathlib import Path
import subprocess
import glob
import json
import traceback
import seamless
from seamless.core.cache.buffer_cache import buffer_cache
from seamless import CacheMissError
from seamless.cmd import yaml_load

parser = argparse.ArgumentParser()
parser.add_argument(
    "-v",
    dest="verbosity",
    help="""Verbose mode.
Multiple -v options increase the verbosity. The maximum is 3""",
    action="count",
    default=0,
)
parser.add_argument(
    "-q", dest="verbosity", help="Quiet mode", action="store_const", const=-1
)

parser.add_argument(
    "-g1",
    help="""Disable file/value guess rule 1.
This rule states that any argument with a file extension must exist as a file.""",
    action="store_true",
)

parser.add_argument(
    "-g2",
    help="""Disable file/value guess rule 2.
This rule states that any argument without file extension must not exist as a file.""",
    action="store_true",
)

parser.add_argument(
    "-w",
    help="""Set the working directory to $HOME.
This allows any file in $HOME to be specified as argument.""",
    dest="workdir",
    action="store_const",
    const=os.path.expanduser("~"),
)

parser.add_argument(
    "-W",
    help="""Set the working directory to /.
This allows any file to be specified as argument.""",
    dest="workdir",
    action="store_const",
    const="/",
)

parser.add_argument(
    "-ms",
    help="""Set the file mapping mode to 'strip'.
Strip directory names. After stripping, all files must be unique.""",
    dest="file_mapping_mode",
    action="store_const",
    const="strip",
)

parser.add_argument(
    "-mr",
    help="""Set the file mapping mode to 'rename'.
Rename to file1, file2, ....""",
    dest="file_mapping_mode",
    action="store_const",
    const="rename",
)

parser.add_argument(
    "-mx",
    help="""Set the file mapping mode to 'rename_with_ext'.
Rename to file1.txt, file2.py, ....""",
    dest="file_mapping_mode",
    action="store_const",
    const="rename_with_ext",
)

parser.add_argument(
    "-c", help="Unquote the command line", dest="unquote", action="store_true"
)

parser.add_argument(
    "--undo",
    help="Undo this seamless command",
    action="store_true"
)

parser.add_argument(
    "--wait",
    help="Wait for earlier seamless commands",
    dest="action",
    action="store_const",
    const="wait",
)

arguments = sys.argv[1:]
command = []
for n, arg in enumerate(sys.argv[1:]):
    if not arg.startswith("-"):
        arguments = sys.argv[1 : n + 1]
        command = sys.argv[n + 1 :]
        break

reformat_wait = False
if command == ["wait"]:
    command = []
    arguments.append("--wait")
    reformat_wait = True

args = parser.parse_args(arguments)

from seamless.cmd.message import set_verbosity, message as msg
from seamless.cmd.commandmode import guess_arguments
from seamless.cmd.file_mapping import get_file_mapping
from seamless.cmd.file_load import files_to_checksums

from seamless.cmd.bash_transformation import run_bash_transformation

verbosity = min(args.verbosity, 3)
set_verbosity(verbosity)
msg(1, "Verbosity set to {}".format(verbosity))

msg(1, "seamless {}".format(__version__))

if reformat_wait:
    msg(1, "'seamless wait' reformatted to 'seamless --wait'")
if args.action is not None:
    assert args.action in ["wait"], args.action
    if args.action == "wait":
        msg(0, "Action set to WAIT")
        raise NotImplementedError  # wait action

msg(3, "Command:", json.dumps(command, indent=4))

if len(command) == 0:
    # TODO: check for --wait and similar
    parser.print_usage()  # TODO: add to usage message
    sys.exit(0)

workdir = os.getcwd()
if args.workdir is not None:
    workdir = args.workdir
    msg(1, "set working directory to: {}".format(workdir))

if args.unquote:
    if len(command) != 1:
        msg(-1, "Unquote requires a single argument")
        sys.exit(1)
    # TODO: better bash lexing
    command = command[0].replace(";", " ; ").split()


def _get_smfile(path: Path) -> Path or None:
    smfiles = [Path(path.as_posix() + ".SEAMLESS.yaml")]
    # TODO: special directory:  - /home/$USER/.seamless/bin-interface/path.SEAMLESS.yaml
    for smfile in smfiles:
        msg(3, "search .SEAMLESS.yaml file... : {}".format(smfile.as_posix()))
        if smfile.exists():
            msg(3, ".SEAMLESS.yaml file found")
            return smfile
        else:
            msg(3, ".SEAMLESS.yaml file not found")
    #smfiles = glob.glob("{}.SEAMLESS.yaml.*".format(stem))
    #msg(3, "glob search .SEAMLESS.yaml file... : {}.SEAMLESS.yaml.*".format(stem))
    smfiles = []
    if len(smfiles):
        smfile = smfiles[0]
        msg(3, ".SEAMLESS.yaml file '{}' found via glob search".format(smfile))
        return Path(smfile)


smfile = None

arg1 = Path(command[0])
if not arg1.exists():
    execarg1 = subprocess.getoutput("which {}".format(arg1.as_posix())).strip()
    if execarg1:
        msg(
            3,
            "first argument '{}' is in PATH, map to '{}'".format(
                arg1.as_posix(), execarg1
            ),
        )
        arg1 = Path(execarg1)
if arg1.exists():
    smfile = _get_smfile(arg1)
    sm_argindex = 0
    if smfile is None:
        msg(2, "first argument '{}' has no .SEAMLESS.yaml file".format(arg1.as_posix()))
    else:
        msg(
            1,
            "found smfile '{}' for first argument '{}'".format(
                smfile, arg1.as_posix()
            ),
        )
else:
    msg(1, "first argument '{}' is not a file".format(arg1.as_posix()))

if smfile is None and len(command) > 1 and not arg1.suffix:
    msg(3, "first argument has no suffix, consider second argument for .SEAMLESS.yaml file")
    arg2 = None
    for n in range(1, len(command)):
        arg = command[n]
        if arg.startswith("-"):
            continue
        arg2 = Path(arg)        
        break
    if arg2 is not None and len(arg2.suffix):
        msg(
            3,
            "second argument '{}' has a suffix, look for .SEAMLESS.yaml file".format(
                arg2.as_posix()
            ),
        )
    if arg2.exists():
        smfile = _get_smfile(arg2)
        sm_argindex = n
        if smfile is None:
            msg(2, "second argument '{}' has no .SEAMLESS.yaml file".format(arg2.as_posix()))
        else:
            msg(
                1,
                "found .SEAMLESS.yaml file '{}' for second argument '{}'".format(
                    smfile, arg2.as_posix()
                ),
            )

if smfile is None:
    msg(2, "no .SEAMLESS.yaml file found")
overrule_ext, overrule_no_ext = False, False
if args.g1:
    msg(1, "disable file/value guess rule 1")
    overrule_ext = True
if args.g2:
    msg(1, "disable file/value guess rule 2")
    overrule_no_ext = True
try:
    argdict = guess_arguments(
        command, overrule_ext=overrule_ext, overrule_no_ext=overrule_no_ext
    )
except ValueError as exc:
    msg(-1, *exc.args)
    sys.exit(1)

argdictstr = json.dumps(argdict, sort_keys=False, indent=2)
msg(1, "argument dict:\n" + argdictstr)

file_mapping_mode = args.file_mapping_mode
if file_mapping_mode is None:
    file_mapping_mode = "literal"
try:
    arg_mapping, file_mapping = get_file_mapping(
        argdict, mapping_mode=file_mapping_mode, working_directory=workdir
    )
except ValueError as exc:
    msg(-1, *exc.args)
    sys.exit(1)

docker_image = None
if smfile is not None:
    msg(2, f"loading {smfile}")
    smdata = yaml_load.load(smfile)
    shim = smdata.get("shim")
    if shim:
        sm_old_argname = argdict["@order"][sm_argindex]
        argdict["@order"][sm_argindex] = shim
        argdict.pop(sm_old_argname)
        argdict[shim] = "value"
    docker_image = smdata.get("environment", {}).get("docker_image")
    argdictstr = json.dumps(argdict, sort_keys=False, indent=2)      
    msg(2, "updated argument dict:\n" + argdictstr)

env = {}

if docker_image is not None:
    msg(1, f'Set Docker image to "{docker_image}"')    
    env["docker"] = {"name": docker_image}

seamless.config.delegate()

# TODO: max_files, max_datasize option
directories = [arg_mapping[arg] for arg in argdict if argdict[arg] == "directory"]

file_checksum_dict = files_to_checksums(
    file_mapping.values(), max_datasize=None, max_files=None, directories=directories
)    
rev_file_mapping = {v: k for k, v in file_mapping.items()}
checksum_dict = {rev_file_mapping[k]: v for k, v in file_checksum_dict.items()}
checksum_dictstr = json.dumps(checksum_dict, sort_keys=True, indent=2)
msg(2, "file/directory checksum dict:\n" + checksum_dictstr)
if len(directories):
    msg(2, "directories:", directories)

mapped_command = []
for arg in argdict["@order"]:
    if argdict[arg] == "value":
        mapped_command.append(arg)
    else:
        mapped_command.append(arg_mapping[arg])
bash_command = " ".join(mapped_command)
msg(1, "bash command:\n", bash_command, "\n")
# TODO: result mode
result_mode = "stdout"
result_checksum = run_bash_transformation(
    bash_command, checksum_dict, directories=directories, result_mode=result_mode, undo=args.undo, environment=env
)
if args.undo:
    # kludge to hide spurious "buffers undestroyed" warnings
    import logging
    logger = logging.getLogger("seamless")
    logger.setLevel(logging.ERROR)
    if result_checksum is None:
        exit(1)
    else:
        msg(1, "Transformation undone")
        exit(0)
try:
    result = buffer_cache.get_buffer(result_checksum)
    if result is None:
        raise CacheMissError(result_checksum)
except CacheMissError:
    traceback.print_exc(limit=1)
    exit(1)
try:
    result = result.decode()
except UnicodeDecodeError:
    pass

print(result)
# TODO: result mode
