
from .. import subprocess_ as subprocess

import numpy as np
import os
from copy import deepcopy
import shutil


cache = {}

def compile(binary_objects, build_dir, *,
    compiler_verbose=False, build_dir_may_exist=False
):
    """Takes a completed definition of a compiled module
     and generates a dict-of-binary-objects (.o / .obj)
    If possible, binary objects are read from cache.
     If not, they are generated by executing compilation commands
    """
    all_done = True
    result = {}
    stderr = "\n"
    success = True

    curr_dir = os.path.abspath(os.getcwd())
    build_dir = os.path.abspath(build_dir)
    all_headers = {}
    source_files = {}
    for objectname, object_ in binary_objects.items():
        for headername, header in object_["headers"].items():
            if headername in all_headers:
                old_header = all_headers[headername]
                if old_header != header:
                    raise Exception("Two different header versions for '%s'" % headername)
            assert header["language"] in ("c", "cpp") # for now, only C/C++ headers; don't know file extensions otherwise
            all_headers[headername] = header
    try:
        try:
            os.makedirs(build_dir) #must be non-existing
        except FileExistsError:
            if not build_dir_may_exist:
                print("WARNING: compiler build dir %s already exists... this could be trouble!" % build_dir)
        os.chdir(build_dir)
        for headername, header in all_headers.items():
            headercode = header["code"]
            header_file = headername + ".h" # hard-code C/C++ for now
            with open(header_file, "w") as f:
                f.write(headercode)
            source_files[header_file] = headercode
        for obj_file, object_ in binary_objects.items():

            if os.path.exists(obj_file):
                os.remove(obj_file)
            cmd = [
              object_["compiler_binary"],
              object_["compile_flag"],
            ]
            for opt in object_["options"]:
                cmd.append(opt)
            cmd += [
              object_["output_flag"],
              os.path.abspath(obj_file)
            ]
            for code_file, code in object_["code_dict"].items():
                cmd.append(os.path.abspath(code_file))
                with open(code_file, "w") as f:
                    f.write(code)
                source_files[code_file] = code
            cmd2 = " ".join(cmd)
            cmd2 = cmd2.replace("{{BUILD_DIR}}", build_dir)
            if compiler_verbose:
                stderr += cmd2 +"\n"
            process = subprocess.run(cmd2,shell=True, capture_output=True)
            #TODO: compilation in parallel
            curr_stderr = process.stderr.decode()
            if process.returncode != 0:
                stderr += "*" * 20 + " ERROR " + "*" * 20 + "\n"
                stderr += curr_stderr + "\n"
                stderr += "*" * 20 + " /ERROR " + "*" * 20 + "\n"
                success = False
            else:
                stderr += curr_stderr + "\n"
                with open(obj_file, "rb") as f:
                    obj = f.read()
                result[obj_file] = obj
    finally:
        os.chdir(curr_dir)
        try:
            shutil.rmtree(build_dir) #TODO: sometimes skip, for GDB
        except Exception:
            pass
    if not len(stderr.replace("\n", "").strip()):
        stderr = ""
    return success, result, source_files, stderr

def complete(module_definition, compilers, languages):
    from silk import Silk
    assert module_definition["type"] == "compiled"
    assert "public_header" in module_definition
    if isinstance(module_definition, Silk):
        module_definition = module_definition.unsilk
    m = deepcopy(module_definition)
    overall_target = module_definition.get("target", "profile")
    m["target"] = overall_target
    m["link_options"] = module_definition.get("link_options", [])
    project_headers = m.pop("headers", {})
    for objectname, object_ in module_definition["objects"].items():
        if "code" not in object_:
            raise Exception("Binary Module, object '%s': no code defined" % objectname)

        o = m["objects"][objectname]
        if not "language" in object_:
            raise Exception("Binary Module, object '%s': no language defined" % objectname)
        lang = object_["language"]
        extension = object_.get("extension")
        _, language, extension2 = find_language(lang, languages)
        if extension is None and extension2 is not None:
            extension = extension2
        if extension is None:
            extension = language["extension"]
        if isinstance(extension, list):
            extension = extension[0]
        o["extension"] = extension

        compiler_name = object_.get("compiler", language.get("compiler"))
        if compiler_name is None:
            raise ValueError("No compiler defined for compiled language '{}'".format(lang))
        o["compiler"] = compiler_name        
        compiler = compilers[compiler_name]
        o["compile_mode"] = compiler.get("mode", "object")
        target = object_.get("target", overall_target)
        if target not in ("release", "debug", "profile"):
            raise ValueError(target)
        o["target"] = target
        std_options = object_.get("options", compiler["options"])
        profile_options = object_.get("profile_options", compiler["profile_options"])
        debug_options = object_.get("debug_options", compiler["debug_options"])
        if target in ("release", "profile"):
            options = list(std_options)
            if target == "profile":
                profile_options = list(profile_options) if isinstance(profile_options, str) else profile_options
                options += profile_options
        else:
            options = list(debug_options)
        o.pop("profile_options", None)
        o.pop("debug_options", None)
        o["options"] = options
        compiler_binary = compiler.get("location", compiler_name)
        o["compiler_binary"] = compiler_binary
        o["compile_flag"] = compiler["compile_flag"]
        o["output_flag"] = compiler["output_flag"]

        o["headers"] = deepcopy(project_headers)
    return m

from . import find_language
