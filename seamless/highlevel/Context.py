import traceback
from copy import deepcopy
from collections import namedtuple
import weakref
import itertools
import threading
import asyncio
import inspect
import functools
import zipfile
from zipfile import ZipFile, ZipInfo
from io import BytesIO
import json

import logging
logger = logging.getLogger("seamless")

def print_info(*args):
    msg = " ".join([str(arg) for arg in args])
    logger.info(msg)

def print_warning(*args):
    msg = " ".join([str(arg) for arg in args])
    logger.warning(msg)

def print_debug(*args):
    msg = " ".join([str(arg) for arg in args])
    logger.debug(msg)

def print_error(*args):
    msg = " ".join([str(arg) for arg in args])
    logger.error(msg)


from .Base import Base
from ..core import macro_mode
from ..core.macro_mode import macro_mode_on, get_macro_mode, until_macro_mode_off
from ..core.context import context
from ..core.cell import cell
from .assign import assign
from .proxy import Proxy
from ..midlevel import copying
from ..midlevel.vault import save_vault, load_vault

Graph = namedtuple("Graph", ("nodes", "connections", "params", "lib"))

def run_in_mainthread(func):
    def func2(*args, **kwargs):
        ctx = args[0]
        manager = ctx._manager
        if threading.current_thread() != threading.main_thread():
            manager.taskmanager.add_synctask(func, args, kwargs, with_event=False)
        else:
            func(*args, **kwargs)
    functools.update_wrapper(func2, func)
    return func2

Graph = namedtuple("Graph", ("nodes", "connections", "params", "lib"))

shareserver = None


def get_status(parent, children, nodes, path):
    from ..core.context import StatusReport
    result = StatusReport()
    if path is not None:
        lp = len(path)
    all_children = itertools.chain(children.items(), nodes.items())
    for childname0, child in all_children:
        if path is not None:
            if childname0[:lp] != path:
                continue
            childname0 = childname0[lp:]
        if len(childname0) != 1:
            continue
        childname = childname0[0]
        if isinstance(child, dict):  # node
            if child["type"] != "context":
                continue
            subpath = (childname,)
            if path is not None:
                subpath = path + subpath
            child = SubContext(parent, subpath)
        s = child.status
        if s != "Status: OK":
            result[childname] = s
    if len(result):
        return result
    else:
        return "Status: OK"

import weakref
_contexts = weakref.WeakSet()
def _destroy_contexts():
    for context in _contexts:
        try:
            context._destroy()
        except:
            pass
import atexit
atexit.register(_destroy_contexts)


def get_zip(buffer_dict):
    archive = BytesIO()
    with ZipFile(archive, mode="w", compression=zipfile.ZIP_DEFLATED) as zipf:
        for checksum in sorted(list(buffer_dict.keys())):
            buffer = buffer_dict[checksum]
            info = ZipInfo(checksum, date_time=(1980, 1, 1, 0, 0, 0))
            zipf.writestr(info, buffer)
    result = archive.getvalue()
    archive.close()
    return result

class Context(Base):
    """Context class. Organizes cells and workers hierarchically.

    See http://sjdv1982.github.io/seamless/sphinx/html/context.html for documentation
    """
    _default_parameters = {
        "share_namespace": "ctx"
    }
    _mount = None
    _translating = False
    _translate_count = 0
    _gen_context = None
    _runtime_graph = None  # the graph as synthesized by pre-translating all LibInstances, overlaying onto the main graph
    _weak = False  # True for autogenerated contexts that have no strong reference
    _live_share_namespace = None
    _destroyed = False

    @classmethod
    def from_graph(cls, graph, manager, *, mounts=True, shares=True, share_namespace=None, zip=None):
        """Constructs a Context from a graph

        "graph" can be a file name or a JSON dict
        Normally, it has been generated with Context.save_graph / Context.get_graph

        "zip" can be a file name, zip-compressed bytes or a Python ZipFile object.
        Normally, it has been generated with Context.save_zip / Context.get_zip

        "manager": re-use the manager of a previous context.
        The manager controls caching and execution.

        "mounts": mount cells and pins to the file system, as specified in the graph.

        "shares": share cells over HTTP, as specified in the graph

        "share_namespace": The namespace to use for HTTP sharing ("ctx"by default)

        """
        self = cls(manager=manager)
        if zip is not None:
            self.add_zip(zip)
        if share_namespace is not None:
            self.share_namespace = share_namespace
        self.set_graph(graph,mounts=mounts,shares=shares)
        graph = deepcopy(graph)
        return self

    def set_graph(self, graph, *, mounts=True, shares=True):
        """Sets the graph of the Context

        "graph" can be a file name or a JSON dict
        Normally, it has been generated with Context.save_graph / Context.get_graph

        "mounts": mount cells and pins to the file system, as specified in the graph.

        "shares": share cells over HTTP, as specified in the graph

        """
        graph = deepcopy(graph)
        nodes = {}
        self._children.clear()
        for node in graph["nodes"]:
            p = tuple(node["path"])
            if not mounts:
                node.pop("mount", None)
            if not shares:
                node.pop("share", None)
            node["path"] = p
            nodes[p] = node
            nodetype = node["type"]
            if nodetype == "libinstance":
                continue
            nodecls = nodeclasses[nodetype]
            child = nodecls(parent=self,path=p)
        connections = graph["connections"]
        for con in connections:
            if con["type"] == "connection":
                con["source"] = tuple(con["source"])
                con["target"] = tuple(con["target"])
            elif con["type"] == "link":
                con["first"] = tuple(con["first"])
                con["second"] = tuple(con["second"])
        params = deepcopy(self._default_parameters)
        params.update(graph["params"])
        lib0 = graph.get("lib", [])
        self._graph = Graph(nodes, connections, params, {})
        for l in lib0:
            path = tuple(l["path"])
            l["path"] = path
            self._set_lib(path, l)
        self._translate()
        return self

    def __init__(self, manager=None):
        """Creates a new Seamless context

        "manager": re-use the manager of a previous context.
        The manager controls caching and execution.
        """
        super().__init__(None, ())
        from seamless.core.manager import Manager
        if manager is not None:
            assert isinstance(manager, Manager), type(manager)
            self._manager = manager
        else:
            self._manager = Manager()
        self._manager._highlevel_refs += 1
        self._graph = Graph({},[],{},{})
        self._graph.params.update(deepcopy(self._default_parameters))
        self._children = {}
        self._needs_translation = True
        self._parent = weakref.ref(self)
        self._traitlets = {}
        self._observers = set()
        _contexts.add(self)

    def _get_node(self, path):
        try:
            return self._graph[0][path]
        except KeyError:
            try:
                return self._runtime_graph.nodes[path]
            except (KeyError, AttributeError):
                raise KeyError(path) from None

    def _get_path(self, path):
        child = self._children.get(path)
        if child is not None:
            return child
        node = self._graph[0].get(path)
        if node is not None:
            if node["type"] == "libinstance":
                return LibInstance(self, path=path)
            assert node["type"] == "context", (path, node["type"]) #if not context, should be in children!
            return SubContext(self, path)
        return Proxy(self, path, "w")

    def _get_subcontext(self, path):
        child = self._children[path]

    def __getitem__(self, attr):
        if not isinstance(attr, str):
            raise KeyError(attr)
        return getattr(self, attr)

    def __setitem__(self, attr, value):
        if not isinstance(attr, str):
            raise KeyError(attr)
        setattr(self, attr, value)

    def __getattribute__(self, attr):
        if attr.startswith("_"):
            return super().__getattribute__(attr)
        if attr in type(self).__dict__ or attr in self.__dict__ or attr == "path":
            return super().__getattribute__(attr)
        path = (attr,)
        return self._get_path(path)

    def __setattr__(self, attr, value):
        if attr.startswith("_"):
            return object.__setattr__(self, attr, value)
        members = {k:v for k,v in inspect.getmembers(type(self))}
        if attr in members and isinstance(members[attr], property):
            return object.__setattr__(self, attr, value)
        attr2 = (attr,)
        if isinstance(value, (Transformer, Macro)):
            if value._parent is None:
                self._graph[0][attr2] = value
                self._children[attr2] = value
                value._init(self, attr2 )
                self._translate()
            else:
                assign(self, attr2, value)
            """
        elif attr2 in self._children:
            child = self._children[attr2]
            if isinstance(child, Cell):
                child.set(value)
            """
        else:
            assign(self, attr2, value)

    def __delattr__(self, attr):
        self._destroy_path((attr,))

    def _add_traitlet(self, path, trigger):
        from .SeamlessTraitlet import SeamlessTraitlet
        traitlet = self._traitlets.get(path)
        if traitlet is not None:
            return traitlet
        traitlet = SeamlessTraitlet(value=None)
        traitlet.parent = weakref.ref(self)
        traitlet.path = path
        if trigger:
            traitlet._connect_seamless()
        self._traitlets[path] = traitlet
        self._translate()
        return traitlet

    def compute(self, timeout=None, report=2):
        """Block until no more computation is required.

        This means that all cells and transformers have either been computed,
        or they have an error, or they have unsatisfied upstream dependencies.

        The graph is first (re-)translated, if necessary.

        This function can only be invoked if no event loop is running,
        i.e. under python or ipython, but not in a Jupyter kernel.
        """
        from seamless import verify_sync_compute
        verify_sync_compute()
        self.translate()
        return self._gen_context.compute(timeout, report)

    async def computation(self, timeout=None, report=2):
        """Block until no more computation is required.

        This means that all cells and transformers have either been computed,
        or they have an error, or they have unsatisfied upstream dependencies.

        The graph is first (re-)translated, if necessary.
        """
        await self.translation()
        await self._gen_context.computation(timeout, report)

    @property
    def self(self):
        attributelist = [k for k in type(self).__dict__ if not k.startswith("_")]
        return SelfWrapper(self, attributelist)

    def _translate(self):
        self._needs_translation = True

    def translate(self, force=False):
        """(Re-)translate the graph.
        The graph is translated to a low-level, computable form
        (seamless.core). After translation, return immediately,
        although computation will start automatically.

        If force=True, translation will happen even though no
        change in topology or celltype was detected.

        This function can only be invoked if no event loop is running,
        i.e. under python or ipython, but not in a Jupyter kernel.
        """
        from seamless import verify_sync_translate
        verify_sync_translate()
        self._wait_for_auth_tasks("the graph is re-translated")
        return self._do_translate(force=force, explicit=True)

    async def translation(self, force=False):
        """(Re-)translate the graph.
        The graph is translated to a low-level, computable form
        (seamless.core). After translation, return immediately,
        although computation will start automatically.

        If force=True, translation will happen even though no
        change in topology or celltype was detected.
        """
        await self._wait_for_auth_tasks_async("the graph is re-translated")
        return await self._do_translate_async(force=force, explicit=True)

    @property
    def share_namespace(self):
        """The preferred namespace for sharing cells by the HTTP server

        Cells are shared under:
         http://<shareserver URL>/<live_share_namespace>/<cell path>

        The live share namespace is in principle equal to the share namespace,
        but if it is already taken, a number will be added to it (ctx1, ctx2, etc.)

        Default: "ctx"
        """
        return self._graph.params["share_namespace"]

    @share_namespace.setter
    def share_namespace(self, value):
        if not isinstance(value, str):
            raise TypeError(value)
        self._graph.params["share_namespace"] = value
        self._live_share_namespace = None

    @property
    def live_share_namespace(self):
        """The actual namespace for sharing cells by the HTTP server

        Cells are shared under:
         http://<shareserver URL>/<live_share_namespace>/<cell path>

        The live share namespace is in principle equal to the share namespace,
        but if it is already taken, a number will be added to it (ctx1, ctx2, etc.)

        Default: "ctx"
        """
        return self._live_share_namespace

    def _get_graph(self, copy):
        self._wait_for_auth_tasks("the graph is being obtained")
        try:
            self._translating = True
            manager = self._manager
            copying.fill_checksums(manager, self._graph.nodes)
        finally:
            self._translating = False
        nodes, connections, params, lib = self._graph
        nodes = [v for k,v in sorted(nodes.items(), key=lambda kv: kv[0])]
        lib = [v for k,v in sorted(lib.items(), key=lambda kv: kv[0])]
        if copy:
            connections = deepcopy(connections)
            nodes = deepcopy(nodes)
            params = deepcopy(params)
            lib = deepcopy(lib)
        graph = {
            "nodes": nodes,
            "connections": connections,
            "params": params,
            "lib": lib,
        }
        return graph

    async def _get_graph_async(self, copy):
        await self._wait_for_auth_tasks_async("the graph is being obtained")
        try:
            self._translating = True
            manager = self._manager
            copying.fill_checksums(manager, self._graph.nodes)
        finally:
            self._translating = False
        nodes, connections, params, lib = self._graph
        nodes = [v for k,v in sorted(nodes.items(), key=lambda kv: kv[0])]
        lib = [v for k,v in sorted(lib.items(), key=lambda kv: kv[0])]
        if copy:
            connections = deepcopy(connections)
            nodes = deepcopy(nodes)
            params = deepcopy(params)
            lib = deepcopy(lib)
        graph = {
            "nodes": nodes,
            "connections": connections,
            "params": params,
            "lib": lib,
        }
        return graph

    def get_graph(self, runtime=False):
        """Returns the graph in JSON format

        "runtime": The graph is returned after
        Library/LibInstance/Macro transformations of the graph.
        """
        if not runtime:
            return self._get_graph(copy=True)

        self._get_graph(copy=True)
        graph0 = deepcopy(self._runtime_graph)

        connections = deepcopy(graph0.connections)
        nodes = deepcopy(graph0.nodes)
        params = deepcopy(graph0.params)
        lib = deepcopy(graph0.lib)
        graph = {
            "nodes": [node for node in nodes.values()],
            "connections": connections,
            "params": params,
            "lib": lib,
        }
        return graph

    def save_graph(self, filename):
        """Saves the graph in JSON format"""
        graph = self.get_graph()
        with open(filename, "w") as f:
            json.dump(graph, f, sort_keys=True, indent=2)

    def get_zip(self, with_libraries=True):
        """Obtain the checksum-to-buffer cache for the current graph

        The cache is returned as zipped bytes
        """
        # TODO: option to not follow deep cell checksums (currently, they are always followed)
        force = (self._gen_context is None)
        self._wait_for_auth_tasks("the graph buffers are obtained for zip")
        self._do_translate(force=force)
        graph = self.get_graph()
        checksums = copying.get_graph_checksums(graph, with_libraries, with_annotations=False)
        manager = self._manager
        buffer_dict = copying.get_buffer_dict_sync(manager, checksums)
        return get_zip(buffer_dict)

    async def get_zip_async(self, with_libraries=True):
        """Obtain the checksum-to-buffer cache for the current graph

        The cache is returned as zipped bytes
        """
        # TODO: option to not follow deep cell checksums (currently, they are always followed)
        force = (self._gen_context is None)
        await self._wait_for_auth_tasks_async("the graph buffers are obtained for zip")
        self._do_translate(force=force)
        graph = self.get_graph()
        checksums = copying.get_graph_checksums(graph, with_libraries, with_annotations=False)
        manager = self._manager
        buffer_dict = await copying.get_buffer_dict(manager, checksums)
        return get_zip(buffer_dict)

    def save_zip(self, filename):
        """Save the checksum-to-buffer cache for the current graph

        The cache is saved to "filename", which should be a .zip file
        """
        zip = self.get_zip()
        with open(filename, "wb") as f:
            f.write(zip)

    async def save_zip_async(self, filename):
        """Save the checksum-to-buffer cache for the current graph

        The cache is saved to "filename", which should be a .zip file
        """
        zip = self.get_zip_async()
        with open(filename, "wb") as f:
            f.write(zip)

    def save_vault(self, dirname, with_libraries=True):
        """Save the checksum-to-buffer cache for the current graph in a vault directory
        """
        # TODO: option to not follow deep cell checksums (currently, they are always followed)
        force = (self._gen_context is None)
        self._wait_for_auth_tasks("the graph buffers are obtained for zip")
        self._do_translate(force=force)
        graph = self.get_graph()
        annotated_checksums = copying.get_graph_checksums(
            graph, with_libraries, with_annotations=True
        )
        manager = self._manager
        checksums = [c[0] for c in annotated_checksums]
        buffer_dict = copying.get_buffer_dict_sync(manager, checksums)
        save_vault(dirname, annotated_checksums, buffer_dict)


    def _set_lib(self, path, lib):
        old_lib = self._graph.lib.get(path)
        self._graph.lib[path] = lib
        if lib is not None:
            checksums = copying.get_checksums(
                lib["graph"]["nodes"],
                lib["graph"]["connections"],
                with_annotations=False
            )
            for checksum in checksums:
                buffer_cache.incref(bytes.fromhex(checksum), True)
        if old_lib is not None:
            old_checksums = copying.get_checksums(old_lib["graph"]["nodes"], [], with_annotations=False)
            for old_checksum in old_checksums:
                buffer_cache.decref(bytes.fromhex(old_checksum))


    def add_zip(self, zip, incref=False):
        """Adds entries from "zip" to the checksum-to-buffer cache

        "zip" can be a file name, zip-compressed bytes or a Python ZipFile object.
        Normally, it has been generated with Context.save_zip / Context.get_zip

        Note that caching is temporary and entries will be removed after some time
        if no element (cell, expression, or high-level library) holds their checksum
        This can be overridden with "incref=True" (not recommended for long-living contexts)

        """
        if self._gen_context is None:
            self._do_translate(force=True)
        manager = self._manager
        if isinstance(zip, bytes):
            archive = BytesIO(zip)
            zipfile = ZipFile(archive, "r")
        elif isinstance(zip, str):
            zipfile = ZipFile(zip, "r")
        elif isinstance(zip, ZipFile):
            zipfile = zip
        elif hasattr(zip, "read") and callable(zip.read):
            zipfile = ZipFile(zip, "r")
        else:
            raise TypeError(type(zip))
        return copying.add_zip(manager, zipfile, incref=incref)

    def load_vault(self, vault_directory, incref=False):
        """Loads the contents of a vault directory in the checksum-to-buffer cache

        Normally, the vault has been generated with Context.save_vault

        Note that caching is temporary and entries will be removed after some time
        if no element (cell, expression, or high-level library) holds their checksum
        This can be overridden with "incref=True" (not recommended for long-living contexts)

        """
        if self._gen_context is None:
            self._do_translate(force=True)
        manager = self._manager
        return load_vault(vault_directory, incref=incref)

    def include(self, lib, only_zip=False, full_path=False):
        """Include a library in the graph

        A library (seamless.highlevel.Library) must be included before
        library instances (seamless.highlevel.LibInstance) can be constructed
        using ctx.lib
        """
        from .library import Library
        if not isinstance(lib, Library):
            raise TypeError(type(lib))
        if only_zip:
            lib.include_zip(self)
        else:
            lib.include(self, full_path=full_path)
        self._translate()


    def _wait_for_auth_tasks(self, what_happens_text):
        if self._gen_context is not None and not asyncio.get_event_loop().is_running():
            taskmanager = self._gen_context._get_manager().taskmanager
            taskmanager.compute(
                timeout=10, report=2,
                get_tasks_func=get_auth_tasks
            )
            auth_lost_cells = set()
            for task in taskmanager.tasks:
                if not isinstance(task, auth_task_types):
                    continue
                if task._canceled:
                    continue
                auth_lost_cells.add(task.dependencies[0])
                task.cancel()

            if len(auth_lost_cells):
                warn = """WARNING: the following cells had their authoritative value under modification while %s
    These modifications have been CANCELED:
    %s""" % (what_happens_text, list(auth_lost_cells))
                print(warn)

    async def _wait_for_auth_tasks_async(self, what_happens_text):
        if self._gen_context is not None:
            taskmanager = self._gen_context._get_manager().taskmanager
            await taskmanager.computation(
                timeout=10, report=2,
                get_tasks_func=get_auth_tasks
            )
            auth_lost_cells = set()
            for task in taskmanager.tasks:
                if not isinstance(task, auth_task_types):
                    continue
                if task._canceled:
                    continue
                auth_lost_cells.add(task.dependencies[0])
                task.cancel()

            if len(auth_lost_cells):
                warn = """WARNING: the following cells had their authoritative value under modification while %s
    These modifications have been CANCELED:
    %s""" % (what_happens_text, list(auth_lost_cells))
                print(warn)

    @run_in_mainthread
    def _do_translate(self, force=False, explicit=False):
        graph0 = self._get_graph(copy=False)
        return self._do_translate2(graph0, force=force, explicit=explicit)

    async def _do_translate_async(self, force=False, explicit=False):
        assert threading.current_thread() == threading.main_thread()
        graph0 = await self._get_graph_async(copy=False)
        await until_macro_mode_off()
        return self._do_translate2(graph0, force=force, explicit=explicit)


    def _do_translate2(self, graph0, force, explicit):
        from ..midlevel.translate import translate, import_before_translate
        from ..midlevel.pretranslate import pretranslate
        from ..core.context import Context as CoreContext
        #from pprint import pprint; pprint(graph0)
        if not force and not self._needs_translation:
            return
        """
        if self._translating:
            raise Exception("Nested invocation of ctx.translate")
        """
        if self._translating:
            return
        graph = pretranslate(self, graph0)
        if graph is not graph0:
            libinstance_nodes = {node["path"]: node for node in graph["nodes"]}
            self._runtime_graph = Graph(
                libinstance_nodes,
                graph["connections"],
                graph["params"],
                graph["lib"]
            )
        else:
            graph0 = deepcopy(graph0)
            self._runtime_graph = Graph(
                {node["path"]: node for node in graph0["nodes"]},
                graph0["connections"],
                graph0["params"],
                graph0["lib"]
            )

        self._translate_count += 1
        livegraph = self._manager.livegraph
        try:
            ok = False
            self._translating = True
            ctx = None
            if self._gen_context is not None:
                self._gen_context.destroy()
                print_info("*" * 30 + "DESTROYED BEFORE TRANSLATE" + "*" * 30)
                ok1 = self._manager.livegraph.check_destroyed()
                ok2 = self._manager.taskmanager.check_destroyed()
                if not ok1 or not ok2:
                    raise Exception("Cannot re-translate, since clean-up of old context was incomplete")
            import_before_translate(graph)
            """ KLUDGE
            The translation process does NOT happen in one async step; it will start launching tasks
            and those tasks will be run.
            This is a problem for the high level observers, that will miss checksum updates
             because they are connected only in the next step.
            We must hold all observations during translation, and flush them afterwards
            """
            livegraph._hold_observations = True
            with macro_mode_on():
                ub_ctx = context(
                    toplevel=True,
                    manager=self._manager
                )
                if self._mount is not None:
                    ub_ctx._mount = self._mount.copy()
                self._unbound_context = ub_ctx
                ub_ctx._root_highlevel_context = weakref.ref(self)
                translate(graph, ub_ctx)
                nodedict = {node["path"]: node for node in graph["nodes"]}
                nodedict0 = {node["path"]: node for node in graph0["nodes"]}
                for path in nodedict:
                    node = nodedict[path]
                    node0 = nodedict0.get(path)
                    if node0 is not None and node is not node0:
                        node0.pop("UNTRANSLATED", None)
            self._gen_context = ub_ctx._bound
            self._gen_context._root_highlevel_context = weakref.ref(self)
            assert self._gen_context._get_manager() is self._manager
            self._connect_share()
            ok = True
        finally:
            if not ok:
                livegraph._hold_observations = False
            self._translating = False
            self._unbound_context = None
            needs_translation = False
            for node in graph0["nodes"]:
                if isinstance(node, dict) and node.get("UNTRANSLATED"):
                    needs_translation = True
                    break
            self._needs_translation = needs_translation

        try:
            self._translating = True
            for path, child in self._children.items():
                if isinstance(child, (Cell, Transformer, Macro, Module)):
                    try:
                        child._set_observers()
                    except Exception:
                        pass
                elif isinstance(child, (PinWrapper, Link)):
                    continue
                else:
                    raise TypeError(type(child))

            for traitlet in self._traitlets.values():
                try:
                    traitlet._connect_seamless()
                except Exception:
                    traceback.print_exc()

        finally:
            livegraph._hold_observations = False
            print_info("*" * 30 + "TRANSLATE COMPLETE" + "*" * 30)
            self._translating = False

        livegraph._flush_observations()

    def _get_shares(self):
        shares = {}
        for path, node in self._graph.nodes.items():
            if node["type"] != "cell":
                continue
            share = node.get("share")
            if share is not None:
                shares[path] = share
        if not len(shares):
            return None
        return shares

    def _connect_share(self):
        shares = self._get_shares()
        if shares is None:
            return
        from ..core import StructuredCell, Cell as core_cell
        global shareserver
        from .. import shareserver
        from ..core.share import sharemanager
        shareserver.start()
        if self._live_share_namespace is None:
            self._live_share_namespace = sharemanager.new_namespace(
                self._manager,
                name=self.share_namespace,
                share_evaluate=False
            )
        for path, shareparams in shares.items():
            key = "/".join(path) #TODO: split in subpaths by inspecting and traversing ctx._children (recursively for subcontext children)
            hcell = self._children[path]
            if not isinstance(hcell, Cell):
                raise NotImplementedError(type(hcell))
            cell = hcell._get_cell()
            if isinstance(cell, StructuredCell):
                pass #TODO: see above
            elif isinstance(cell, core_cell):
                pass #TODO: see above
            else:
                raise TypeError(cell)
            sharepath = shareparams["path"]
            readonly = shareparams["readonly"]
            mimetype = hcell.mimetype
            toplevel = shareparams.get("toplevel", False)
            cell.share(
                sharepath, readonly,
                mimetype=mimetype, toplevel=toplevel,
                cellname="." + ".".join(path)
            )

    def _rename_path(self, path, newpath):
        raise NotImplementedError

    def _destroy_path(self, path, runtime=False):
        graph = self._graph
        if runtime:
            if self._runtime_graph is None:
                return
            graph = self._runtime_graph
        nodes = graph.nodes
        for p in list(nodes.keys()):
            if p[:len(path)] == path:
                node = nodes[p]
                child = self._children.get(p)
                nodes.pop(p)
                self._children.pop(p, None)
                self._traitlets.pop(p, None)
                if not runtime:
                    self._translate()

        nodes = graph.nodes
        l = len(nodes)
        newnodes = {k:v for k,v in nodes.items() \
                    if k[:len(path)] != path }
        if len(newnodes) < l:
            nodes.clear()
            nodes.update(newnodes)
            if not runtime:
                self._translate()

        removed = self.remove_connections(path, runtime=runtime)
        if removed and not runtime:
            self._translate()

    @property
    def status(self):
        """The computation status of the context
        Returns a dictionary containing the status of all children that are not OK.
        If all children are OK, returns "Status: OK"
        """
        nodes, _, _, _ = self._graph
        return get_status(self, self._children, nodes, path=None)

    @property
    def lib(self):
        """Returns the libraries that were included in the graph"""
        from .library.include import IncludedLibraryContainer
        return IncludedLibraryContainer(self, ())

    def resolve(self, checksum, celltype=None):
        """Returns the data buffer that corresponds to the checksum.
        If celltype is provided, a value is returned instead

        The checksum must be a SHA3-256 hash, as hex string or as bytes"""
        return self._manager.resolve(checksum, celltype=celltype, copy=True)

    def observe(self, path, callback, polling_interval, observe_none=False, params=None):
        """Observes attributes of the context, analogous to Cell.observe"""

        observer = PollingObserver(
            self, path, callback, polling_interval,
            observe_none=observe_none,
            params=params
        )
        self._observers.add(observer)
        return observer

    def unobserve(self, path=()):
        """Analogous to Cell.unobserve"""
        lp = len(path)
        for obs in list(self._observers):
            if obs.path[:lp] == path:
                self._observers.remove(obs)

    def _get_libs(self, path):
        lib = self._graph.lib
        lp = len(path)
        result = {k[lp:]:v for k,v in lib.items() \
                  if len(k) > lp and k[:lp] == path \
                }
        return result

    def _get_lib(self, path):
        return self._graph.lib[tuple(path)]

    def remove_connections(self, path, *,
        runtime=False, endpoint="both", match="sub"
    ):
        """Removes all connections/links with source or target matching path

        "endpoint" can be "source", "target", "connection", "link" or "all".
        With endpoint "source", only remove connections where the source matches path. Don't remove links.
        With endpoint "target", only remove connections where the target matches path. Don't remove links.
        With endpoint "both", only remove connections where source or target matches path. Don't remove links.
        With endpoint "link", remove links where "first" or "second" matches path. Don't remove connections

        "match" can be "super", "exact", or "sub".
        If "super", only paths P that are shorter or equal to "path" are matched. The start of P must be identical to "path"
        If "exact", only paths P that are equal to "path" are matched
        If "sub", only paths that are longer to "path" are matched. The start of "path" must be identical to P.
        If "all", all longer and shorter paths are matched.
        """
        assert endpoint in ("source", "target", "both", "link", "all")
        assert match in ("super", "sub", "exact", "all")
        lp = len(path)
        def matches(p):
            if match == "exact":
                return (p == path)
            elif match == "super":
                return path[:len(p)] == p
            elif match == "sub":
                return p[:lp] == path
            else: # all
                return p[:lp] == path or path[:len(p)] == p

        def keep_con(con):
            if con["type"] == "link":
                if endpoint not in ("link", "all"):
                    return True
                first = con["first"]
                if matches(first):
                    return False
                second = con["second"]
                if matches(second):
                    return False
                return True
            else:
                csource = con["source"]
                if endpoint in ("source", "both", "all"):
                    if matches(csource):
                        return False
                ctarget = con["target"]
                if endpoint in ("target", "both", "all"):
                    if matches(ctarget):
                        return False
                return True
        connections = self._graph[1]
        if runtime:
            connections = self._runtime_graph[1]
        new_connections = list(filter(keep_con, connections))
        any_removed = (len(new_connections) < len(connections))
        connections[:] = new_connections
        return any_removed

    def link(self, first, second):
        """Creates a bidirectional link between the first and second cell

        Both cells must be authoritative
        """
        link = Link(self, first=first, second=second)
        connections = self._graph.connections
        connections.append(link._node)
        self._translate()

    def get_links(self):
        connections = self._graph.connections
        result = []
        for node in connections:
            if node["type"] == "link":
                result.append(Link(self, node=node))
        return result

    def get_children(self, type=None):
        """Returns all children of the context
        The type of the children can be specified as string
        If type is None, all children and descendants are returned:
        - SubContexts are not returned, but their children and descendants are (with full path info)
        - For LibInstance, the children and descendants of the generated SynthContext is returned"""
        classless = ("context", "libinstance")
        all_types = list(classless) + list(nodeclasses.keys())
        assert type is None or type in all_types, (type, all_types)
        children00 = []
        for p,c in self._children.items():
            if isinstance(c, LibInstance) and type != "libinstance":
                for child in c.ctx.get_children():
                    children00.append((child.path, child))
            else:
                children00.append((p, c))
        children0 = children00
        if type is not None and type not in classless:
            klass = nodeclasses[type]
            children0 = [(p,c) for p,c in children00 if isinstance(c, klass)]
        children = [p[0] for p,c in children0]
        if type == "context":
            children = [p for p in children if (p,) not in children00]
        return sorted(list(set(children)))

    @property
    def children(self):
        """Returns a wrapper for the direct children of the context
        This includes subcontexts"""
        children = [p[0] for p in self._children]
        children = sorted(list(set(children)))
        return ChildrenWrapper(self, children)

    def __dir__(self):
        d = [p for p in type(self).__dict__ if not p.startswith("_")]
        children = [p[0] for p in self._children]
        children = list(set(children))
        return sorted(d + children)

    def _destroy(self):
        if self._destroyed:
            return
        self._destroyed = True
        self._manager._highlevel_refs -= 1
        if self._gen_context is not None:
            self._gen_context.destroy()
        for lib in self._graph.lib.values():
            checksums = copying.get_checksums(
                lib["graph"]["nodes"],
                lib["graph"]["connections"],
                with_annotations=False
            )
            for checksum in checksums:
                buffer_cache.decref(bytes.fromhex(checksum))

    def __str__(self):
        p = self.path
        if p == "":
            p = "<toplevel>"
        ret = "Seamless Context: " + p
        return ret

    def __repr__(self):
        return str(self)

    def __del__(self):
        self._destroy()



class SubContext(Base):
    def __init__(self, parent, path):
        super().__init__(parent, path)

    def __getitem__(self, attr):
        if not isinstance(attr, str):
            raise KeyError(attr)
        return getattr(self, attr)

    def __setitem__(self, attr, value):
        if not isinstance(attr, str):
            raise KeyError(attr)
        setattr(self, attr, value)

    def __getattribute__(self, attr):
        if attr.startswith("_"):
            return super().__getattribute__(attr)
        if attr in type(self).__dict__ or attr in self.__dict__ or attr == "path":
            return super().__getattribute__(attr)
        parent = self._get_top_parent()
        path = self._path + (attr,)
        return parent._get_path(path)

    def __setattr__(self, attr, value):
        if attr.startswith("_"):
            return object.__setattr__(self, attr, value)
        parent = self._get_top_parent()
        path = self._path + (attr,)
        if isinstance(value, Transformer):
            if value._parent is None:
                parent._graph[0][path] = value
                parent._children[path] = value
                value._init(parent, path )
                parent._translate()
            else:
                assign(parent, path, value)
        else:
            assign(parent, path, value)

    def __delattr__(self, attr):
        parent = self._get_top_parent()
        path = self._path + (attr,)
        parent._destroy_path(path)

    def _get_graph(self, copy, runtime=False):
        parent = self._parent()
        parent._wait_for_auth_tasks("the graph is being obtained")
        nodes, connections, params, _ = parent._graph
        path = self._path
        lp = len(path)
        newnodes = []
        for nodepath, node in sorted(nodes.items(), key=lambda kv: kv[0]):
            if len(nodepath) > lp and nodepath[:lp] == path:
                newnode = deepcopy(node)
                newnode["path"] = nodepath[lp:]
                newnodes.append(newnode)
        new_connections = []
        for connection in connections:
            if connection["type"] == "connection":
                source, target = connection["source"], connection["target"]
                if source[:lp] == path and target[:lp] == path:
                    con = deepcopy(connection)
                    con["source"] = source[lp:]
                    con["target"] = target[lp:]
                    new_connections.append(con)
            elif connection["type"] == "link":
                first, second = connection["first"], connection["second"]
                if first[:lp] == path and second[:lp] == path:
                    con = deepcopy(connection)
                    con["first"] = first[lp:]
                    con["second"] = second[lp:]
                    new_connections.append(con)
        if copy:
            params = deepcopy(params)
        graph = {
            "nodes": newnodes,
            "connections": new_connections,
            "params": params
        }
        return graph

    def get_graph(self, runtime=False):
        graph = self._get_graph(copy=True, runtime=runtime)
        return graph

    @property
    def status(self):
        parent = self._parent()
        nodes, _, _, _ = parent._graph
        return get_status(parent, parent._children, nodes, self._path)

    def _translate(self):
        self._parent()._translate()

    def get_children(self, type=None):
        classless = ("context", "libinstance")
        assert type is None or type in classless or type in nodeclasses, (type, nodeclasses.keys())
        l = len(self._path)
        children00 = [(p[l:],c) for p,c in self._parent()._children.items() if len(p) > l and p[:l] == self._path]
        children0 = children00
        if type is not None and type not in classless:
            klass = nodeclasses[type]
            children0 = [(p,c) for p,c in children00 if isinstance(c, klass)]
        children = [p[0] for p,c in children0]
        if type == "context":
            children = [p for p in children if (p,) not in children00]
        return sorted(list(set(children)))

    @property
    def children(self):
        result = {}
        parent = self._get_top_parent()
        for k in self.get_children(type=None):
            path = self._path + (k,)
            child = parent._get_path(path)
            result[k] = child
        return result

    def __str__(self):
        ret = "Seamless SubContext: " + self.path
        return ret

    def __repr__(self):
        return str(self)

    def __dir__(self):
        d = [p for p in type(self).__dict__ if not p.startswith("_")]
        return sorted(d + self.get_children())

from .Transformer import Transformer
from .Cell import Cell
from .Link import Link
from .Macro import Macro
from .Module import Module
from .SelfWrapper import SelfWrapper, ChildrenWrapper
from .pin import PinWrapper
from .library.libinstance import LibInstance
from .PollingObserver import PollingObserver

nodeclasses = {
    "cell": Cell,
    "transformer": Transformer,
    "context": SubContext,
    "macro": Macro,
    "module": Module
}

from ..core.manager.tasks.structured_cell import StructuredCellAuthTask
from ..core.manager.tasks import SetCellValueTask, SetCellBufferTask
auth_task_types = (
    SetCellValueTask, SetCellBufferTask, StructuredCellAuthTask
)

def get_auth_tasks(taskmanager):
    tasks = []
    for task in taskmanager.tasks:
        if isinstance(task, auth_task_types):
            tasks.append(task)
    return tasks

from ..core.cache.buffer_cache import buffer_cache