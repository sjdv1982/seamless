{
  "link_options": [],
  "objects": {
    "main": {
      "code": "\n#include <cstdio>\n#include <cmath>\n#include <cassert>\n#include <cstring>\n\ntypedef double Matrix[3][3];\ntypedef double Vector[3];\ntypedef uint Cluster[4];\n\ntypedef struct HierarchyStruct\n{\n    const double *data;\n    unsigned int shape[1];\n} HierarchyStruct;\n\ntypedef struct RandomRotationsStruct\n{\n    const double *data;\n    unsigned int shape[3];\n} RandomRotationsStruct;\n\ntypedef struct ScalevecStruct\n{\n    const double *data;\n    unsigned int shape[1];\n} ScalevecStruct;\n\ntypedef struct ResultStruct\n{\n    double *data;\n    unsigned int shape[3];\n} ResultStruct;\n\nextern \"C\" int transform(const HierarchyStruct *hierarchy, const RandomRotationsStruct *random_rotations, const ScalevecStruct *scalevec, ResultStruct *result);\n\n///////////////////\n\ninline int sign(int x)\n{\n    return (x > 0) - (x < 0);\n}\n\ninline double norm(const Vector &v)\n{\n    return sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);\n}\n\ninline void get_axis_angle(const Matrix &mat, Vector &axis, double &angle)\n{\n    //From https://github.com/rock-learning/pytransform3d/blob/master/pytransform3d/rotations.py\"\"\"\n    double trace = mat[0][0] + mat[1][1] + mat[2][2];\n    angle = acos((trace - 1.0) / 2.0);\n\n    if (fabs(angle) < 1e-12)\n    { // mat == identity\n        axis[0] = 1;\n        axis[1] = 0;\n        axis[2] = 0;\n        angle = 0;\n    }\n    else\n    {\n        /*\n        # We can usually determine the rotation axis by inverting Rodrigues'\n        # formula. Subtracting opposing off-diagonal elements gives us\n        # 2 * sin(angle) * e,\n        # where e is the normalized rotation axis.\n        */\n        Vector axis_unnormalized = {\n            mat[2][1] - mat[1][2],\n            mat[0][2] - mat[2][0],\n            mat[1][0] - mat[0][1]\n        };\n\n        if (fabs(angle - M_PI) < 1e-4)\n        { // trace(mat) close to -1\n            /*\n            # The threshold is a result from this discussion:\n            # https://github.com/rock-learning/pytransform3d/issues/43\n            # The standard formula becomes numerically unstable, however,\n            # Rodrigues' formula reduces to mat = I + 2 (ee^T - I), with the\n            # rotation axis e, that is, ee^T = 0.5 * (mat + I) and we can find the\n            # squared values of the rotation axis on the diagonal of this matrix.\n            # We can still use the original formula to reconstruct the signs of\n            # the rotation axis correctly.\n            */\n            axis[0] = sqrt(0.5 * (mat[0][0] + 1.0)) * sign(axis_unnormalized[0]);\n            axis[1] = sqrt(0.5 * (mat[1][1] + 1.0)) * sign(axis_unnormalized[1]);\n            axis[2] = sqrt(0.5 * (mat[2][2] + 1.0)) * sign(axis_unnormalized[2]);\n        }\n        else\n        {            \n            axis[0] = axis_unnormalized[0];\n            axis[1] = axis_unnormalized[1];\n            axis[2] = axis_unnormalized[2];            \n            /*\n            # The norm of axis_unnormalized is 2.0 * np.sin(angle), that is, we\n            # could normalize with a[:3] = a[:3] / (2.0 * np.sin(angle)),\n            # but the following is much more precise for angles close to 0 or pi:\n            */\n\n            double axnorm = norm(axis);\n            axis[0] /= axnorm;\n            axis[1] /= axnorm;\n            axis[2] /= axnorm;\n        }\n    }\n}\n\ninline void dif_matrix(const Matrix &mat1, const Matrix &mat2, Matrix &result)\n{\n    //mat1.dot(mat2.T)\n    result[0][0] = mat1[0][0] * mat2[0][0] + mat1[0][1] * mat2[0][1] + mat1[0][2] * mat2[0][2];\n    result[0][1] = mat1[0][0] * mat2[1][0] + mat1[0][1] * mat2[1][1] + mat1[0][2] * mat2[1][2];\n    result[0][2] = mat1[0][0] * mat2[2][0] + mat1[0][1] * mat2[2][1] + mat1[0][2] * mat2[2][2];\n\n    result[1][0] = mat1[1][0] * mat2[0][0] + mat1[1][1] * mat2[0][1] + mat1[1][2] * mat2[0][2];\n    result[1][1] = mat1[1][0] * mat2[1][0] + mat1[1][1] * mat2[1][1] + mat1[1][2] * mat2[1][2];\n    result[1][2] = mat1[1][0] * mat2[2][0] + mat1[1][1] * mat2[2][1] + mat1[1][2] * mat2[2][2];\n\n    result[2][0] = mat1[2][0] * mat2[0][0] + mat1[2][1] * mat2[0][1] + mat1[2][2] * mat2[0][2];\n    result[2][1] = mat1[2][0] * mat2[1][0] + mat1[2][1] * mat2[1][1] + mat1[2][2] * mat2[1][2];\n    result[2][2] = mat1[2][0] * mat2[2][0] + mat1[2][1] * mat2[2][1] + mat1[2][2] * mat2[2][2];\n}\n\ninline double vecsum(const Vector &v)\n{\n    return v[0] + v[1] + v[2];\n}\n\ninline double get_msd(const Matrix &dmat, const Vector &scalevec)\n{\n    double ang;\n    Vector ax;\n    get_axis_angle(dmat, ax, ang);\n    double x = cos(ang) - 1;\n    double y = sin(ang);\n    double fac = x * x + y * y;\n\n    double cross_sum =\n        scalevec[0] * scalevec[0] * (1 - ax[0] * ax[0]) +\n        scalevec[1] * scalevec[1] * (1 - ax[1] * ax[1]) +\n        scalevec[2] * scalevec[2] * (1 - ax[2] * ax[2]);\n\n    double msd = fac * cross_sum;\n    return msd;\n}\n\nbool is_close_to_cluster(\n    const Matrix &mat, uint matnr, const Matrix *random_mats,\n    const Cluster *clusters, const uint *indices,\n    uint curr_cluster,\n    const Vector &scalevec,\n    float *cum_thresholds, uint nthresholds,\n    int hierarchy_pos)\n{\n    const Cluster &c = clusters[curr_cluster];\n    uint c_matindex = c[0];\n    uint c_offset = c[1];\n    uint c_size = c[2];\n    if (curr_cluster == 0)\n    {\n        assert(hierarchy_pos == -1);\n    }\n    else\n    {\n        assert(hierarchy_pos >= 0);\n        const Matrix &c_mat = random_mats[c_matindex];\n        Matrix dmat;\n        dif_matrix(mat, c_mat, dmat);\n        double msd = get_msd(dmat, scalevec);\n        //printf(\"MSD1 %d %.6f %.3f\\n\", hierarchy_pos, msd, cum_thresholds[hierarchy_pos]);\n        if (msd > cum_thresholds[hierarchy_pos])\n            return false;\n    }\n    if (hierarchy_pos == nthresholds - 2)\n    {\n        for (uint childnr = 0; childnr < c_size; childnr++)\n        {\n            uint child = indices[c_offset + childnr];\n            const Matrix &c_mat = random_mats[child];\n            Matrix dmat;\n            dif_matrix(mat, c_mat, dmat);\n            double msd = get_msd(dmat, scalevec);\n            //printf(\"MSD2 %d %.6f %.3f %d %d\\n\", nthresholds - 1, msd, cum_thresholds[-1], childnr, child);\n            if (msd < cum_thresholds[nthresholds-1])\n                return true;\n        }\n        return false;\n    }\n\n    for (uint childnr = 0; childnr < c_size; childnr++)\n    {\n        uint ind = indices[c_offset + childnr];\n        bool result = is_close_to_cluster(\n            mat, matnr, random_mats,\n            clusters, indices,\n            ind,\n            scalevec, cum_thresholds,\n            nthresholds,\n            hierarchy_pos + 1);\n        if (result)\n            return true;\n    }\n    return false;\n}\n\nvoid add_to_cluster(\n    Cluster &clus,\n    uint &index, uint *indices, uint &nindices)\n{\n    uint &c_matindex = clus[0];\n    uint &c_offset = clus[1];\n    uint &c_size = clus[2];\n    uint &c_maxsize = clus[3];\n    if (c_size == c_maxsize)\n    {\n        uint new_maxsize = 2 * c_maxsize;\n        memcpy(indices + nindices, indices + c_offset, c_size * sizeof(uint));\n        c_offset = nindices;\n        c_maxsize = new_maxsize;\n        nindices += new_maxsize;\n    }\n    indices[c_offset + c_size] = index;\n    c_size++;\n}\n\nvoid new_cluster(\n    uint matindex,\n    Cluster *clusters, uint &nclusters,\n    uint *indices, uint &nindices)\n{\n    uint ini_size = 10;\n    Cluster &clus = clusters[nclusters];\n    clus[0] = matindex;\n    clus[1] = nindices;\n    clus[2] = 0;\n    clus[3] = ini_size;\n    nclusters++;\n    nindices += ini_size;\n}\n\nvoid new_clusters(\n    uint matindex,\n    Cluster *clusters, uint &nclusters,\n    uint *indices, uint &nindices,\n    uint nest)\n{\n    new_cluster(matindex, clusters, nclusters, indices, nindices);\n    Cluster &clus = clusters[nclusters - 1];\n    if (nest == 1)\n    {\n        //printf(\"ADD   %d %d %d %d\\n\", 1, nclusters-1, matindex, clusters[nclusters-1][2]+1);\n        add_to_cluster(clus, matindex, indices, nindices);\n        return;\n    }\n    //printf(\"PRE   %d %d %d\\n\", nest, nclusters-1, nclusters);\n    add_to_cluster(clus, nclusters, indices, nindices);\n    new_clusters(matindex, clusters, nclusters, indices, nindices, nest - 1);\n}\n\nbool insert_in_clustering(\n    uint matnr, const Matrix &mat, const Matrix *random_mats,\n    Cluster *clusters, uint &nclusters,\n    uint *indices, uint &nindices,\n    uint curr_cluster,\n    const Vector &scalevec,\n    float *thresholds, uint nthresholds,\n    int hierarchy_pos)\n{\n    const Cluster &c = clusters[curr_cluster];\n    uint c_matindex = c[0];\n    uint c_offset = c[1];\n    uint c_size = c[2];\n    if (curr_cluster == 0)\n    {\n        assert(hierarchy_pos == -1);\n    }\n    else\n    {\n        assert(hierarchy_pos >= 0);\n        const Matrix &c_mat = random_mats[c_matindex];\n        Matrix dmat;\n        dif_matrix(mat, c_mat, dmat);\n        double msd = get_msd(dmat, scalevec);\n        //printf(\"MSD3 %d %.6f %.3f %d %d\\n\", hierarchy_pos, msd, thresholds[hierarchy_pos], curr_cluster, c_matindex);\n        if (msd > thresholds[hierarchy_pos])\n            return false;\n    }\n    bool found = false;\n    if (hierarchy_pos == nthresholds - 2)\n    {\n        //printf(\"ADD2  %d %d %d\\n\", curr_cluster, matnr, clusters[curr_cluster][2]+1);\n        add_to_cluster(clusters[curr_cluster], matnr, indices, nindices);\n    }\n    else\n    {\n        for (uint childnr = 0; childnr < c_size; childnr++)\n        {\n            uint ind = indices[c_offset + childnr];\n            bool result = insert_in_clustering(\n                matnr, mat,\n                random_mats,\n                clusters, nclusters,\n                indices, nindices,\n                ind,\n                scalevec,\n                thresholds, nthresholds,\n                hierarchy_pos + 1);\n            if (result)\n                return true;\n        }\n        //printf(\"PRE2  %d %d\\n\", curr_cluster, nclusters);\n        add_to_cluster(clusters[curr_cluster], nclusters, indices, nindices);\n        new_clusters(\n            matnr,\n            clusters, nclusters,\n            indices, nindices,\n            nthresholds - 2 - hierarchy_pos);\n    }\n    return true;\n}\n\nint build_rotamers(\n    const Matrix *random_mats,\n    uint nrandom_mats,\n    const Vector &scalevec,\n    const double *hierarchy,\n    uint nhierarchy,\n    Matrix *result)\n{\n    uint max_clusters = uint(1e07);\n    uint max_indices = uint(1e08);\n    Cluster *clusters = (Cluster *)malloc(max_clusters * sizeof(Cluster));\n    uint nclusters = 0;\n    uint *indices = (uint *)malloc(max_indices * sizeof(uint));\n    uint nindices = 0;\n    new_cluster(0, clusters, nclusters, indices, nindices);\n    float thresholds[nhierarchy];\n    float cum_thresholds[nhierarchy];\n    float cumsum = 0;\n    int nresult = 0;\n    for (int n = 0; n < nhierarchy; n++)\n    {\n        int nrev = nhierarchy - n - 1;\n        float h = hierarchy[n];\n        thresholds[nrev] = h*h;\n        cumsum += h;\n        cum_thresholds[nrev] = cumsum*cumsum;\n    }\n    \n    for (uint matnr = 0; matnr < nrandom_mats; matnr++){\n        //printf(\"CONF  %d\\n\", matnr);\n        const Matrix &mat = random_mats[matnr];\n        bool close = is_close_to_cluster(\n            mat, matnr, random_mats,\n            clusters, indices,\n            0, scalevec,\n            cum_thresholds, nhierarchy,\n            -1\n        );\n        //printf(\"CLOSE %d %d\\n\", matnr, close);\n        //printf(\"STAT %d %d\\n\", nclusters, nindices);\n        if (!close){\n            memcpy(result + nresult, mat, sizeof(mat));\n            nresult++;\n            insert_in_clustering (\n                matnr, mat, random_mats,\n                clusters, nclusters,\n                indices, nindices,\n                0, scalevec,\n                thresholds, nhierarchy,\n                -1\n            );\n        }\n        //print_clust(0, clusters, indices, 0, hierarchy)\n        //print()\n    }\n    //print_clust(0, clusters, indices, 0, hierarchy)\n    free(clusters);\n    free(indices);\n    return nresult;\n}\n\nextern \"C\" int transform(\n    const HierarchyStruct *hierarchy, const RandomRotationsStruct *random_rotations,\n    const ScalevecStruct *scalevec, ResultStruct *result)\n{\n    int nrotamers = build_rotamers(  \n        (const Matrix *) random_rotations->data, \n        random_rotations->shape[0],\n        *((const Vector *) scalevec->data),\n        hierarchy->data, \n        hierarchy->shape[0],\n        (Matrix *) result->data\n    );\n\n    result->shape[0] = nrotamers;\n    return 0;\n}",
      "language": "cpp"
    }
  },
  "public_header": {
    "code": "\n/*\nThe following C header has been auto-generated from the transformer schema\nIt will be used to generate bindings, but it will not be automatically\nadded to the compiled transformer code.\n\nIf your transformer code is written in C/C++, you may do so yourself.\nFor C, you may need to include \"stdint.h\" and \"stdbool.h\".\nIf your transform() function is written in C++, don't forget to add 'extern \"C\" '\n*/\n\ntypedef struct HierarchyStruct {\n  const double *data;\n  unsigned int shape[1];\n} HierarchyStruct;\n\ntypedef struct RandomRotationsStruct {\n  const double *data;\n  unsigned int shape[3];\n} RandomRotationsStruct;\n\ntypedef struct ScalevecStruct {\n  const double *data;\n  unsigned int shape[1];\n} ScalevecStruct;\n\ntypedef struct ResultStruct {\n  double *data;\n  unsigned int shape[3];\n} ResultStruct;\n\nint transform(const HierarchyStruct* hierarchy, const RandomRotationsStruct* random_rotations, const ScalevecStruct* scalevec, ResultStruct *result);",
    "language": "c"
  },
  "type": "compiled"
}
